
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Angular学习笔记 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.7.5">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="flutter的学习笔记.html" />
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Angular
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1" data-path="Angular学习笔记.html">
            
                <a href="Angular学习笔记.html">
            
                    
                    Angular学习笔记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="flutter的学习笔记.html">
            
                <a href="flutter的学习笔记.html">
            
                    
                    flutter的学习笔记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    js进阶
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../js进阶/异步编程.html">
            
                <a href="../js进阶/异步编程.html">
            
                    
                    异步编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../js进阶/设计模式.html">
            
                <a href="../js进阶/设计模式.html">
            
                    
                    设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../js进阶/轮播图设计.html">
            
                <a href="../js进阶/轮播图设计.html">
            
                    
                    轮播图设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../js进阶/高阶函数.html">
            
                <a href="../js进阶/高阶函数.html">
            
                    
                    高阶函数
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    node
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../node/node_01.html">
            
                <a href="../node/node_01.html">
            
                    
                    node_01
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../node/node_02.html">
            
                <a href="../node/node_02.html">
            
                    
                    node_02
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../node/node_03.html">
            
                <a href="../node/node_03.html">
            
                    
                    node_03
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../node/node与mongDB.html">
            
                <a href="../node/node与mongDB.html">
            
                    
                    node与mongDB
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../node/node基础.html">
            
                <a href="../node/node基础.html">
            
                    
                    node基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../node/node的web框架koa.html">
            
                <a href="../node/node的web框架koa.html">
            
                    
                    node的web框架koa
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    react
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../react/React前厅（基础）.html">
            
                <a href="../react/React前厅（基础）.html">
            
                    
                    React前厅（基础）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    vue
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../vue/TypeScript.html">
            
                <a href="../vue/TypeScript.html">
            
                    
                    TypeScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../vue/vue3.html">
            
                <a href="../vue/vue3.html">
            
                    
                    vue3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../vue/vue基础.html">
            
                <a href="../vue/vue基础.html">
            
                    
                    vue基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../vue/vue生态.html">
            
                <a href="../vue/vue生态.html">
            
                    
                    vue生态
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                    杂篇
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../杂篇/直播.html">
            
                <a href="../杂篇/直播.html">
            
                    
                    直播
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../杂篇/预习资料.html">
            
                <a href="../杂篇/预习资料.html">
            
                    
                    预习资料
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../计算机网络/计算机网络.html">
            
                <a href="../计算机网络/计算机网络.html">
            
                    
                    计算机网络
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../计算机网络/工具链和其他.html">
            
                <a href="../计算机网络/工具链和其他.html">
            
                    
                    工具链和其他
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../计算机网络/浏览器状态同步和路由.html">
            
                <a href="../计算机网络/浏览器状态同步和路由.html">
            
                    
                    浏览器状态同步和路由
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../计算机网络/网络安全攻防.html">
            
                <a href="../计算机网络/网络安全攻防.html">
            
                    
                    网络安全攻防
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Angular学习笔记</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <blockquote>
<p><a href="http://ts.xcatliu.com/" target="_blank">http://ts.xcatliu.com/</a> ： typescript入门</p>
<p><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank">https://jkchao.github.io/typescript-book-chinese/</a> ： 深入typescriot</p>
<p><a href="http://angular.cn/guide/setup-local" target="_blank">http://angular.cn/guide/setup-local</a> ： angular官方教程</p>
<p><a href="https://docs.microsoft.com/zh-cn/" target="_blank">https://docs.microsoft.com/zh-cn/</a> ： 微软官方文档</p>
</blockquote>
<p>[TOC]</p>
<h2 id="sotre实战上手">Sotre实战上手</h2>
<ul>
<li>查看<code>npm</code>全局安装的包<code>npm list -g --depth 0</code></li>
</ul>
<h3 id="angular-cli">Angular CLI</h3>
<ul>
<li>安装<code>npm install -g @angular/cli</code></li>
<li>创建项目 <code>ng new &lt;project-name&gt;</code></li>
<li>创建一个组件<code>ng generator component &lt;component-name&gt;</code> </li>
<li>创建一个服务<code>ng generator service &lt;component-name&gt;</code> </li>
<li>版本降级<ul>
<li>全局卸载<code>npm uninstall -g @angular/cli</code></li>
<li>清除缓存<code>npm cache clean --force</code>，并检验是否卸载完毕<code>ng v</code></li>
<li>安装指定版本<code>npm install -g @angular/cli@13</code></li>
</ul>
</li>
</ul>
<h3 id="组件通信">组件通信</h3>
<p>父组件向子组件传递数据；以及子组件向父组件传递事件</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { Component, EventEmitter, Input, OnInit, Output } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;
<span class="hljs-keyword">interface</span> Product {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  name: <span class="hljs-built_in">string</span>;
  price: <span class="hljs-built_in">number</span>;
  description: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductAlertsComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{
  <span class="hljs-comment">// 父 =&gt; 子 子组件需要声明input()属性</span>
  <span class="hljs-comment">// 子 =&gt; 父 output() 定义EventEmitter事件</span>
  <span class="hljs-meta">@Input</span>() product!: Product
  <span class="hljs-meta">@Output</span>() notify = <span class="hljs-keyword">new</span> EventEmitter()
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { }
  ngOnInit(): <span class="hljs-built_in">void</span> { }
}
</code></pre>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;app-product-lists&apos;</span>,
  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&apos;./product-lists.component.html&apos;</span>,
  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&apos;./product-lists.component.css&apos;</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">` 
  &lt;app-product-alerts 
      [product]=&quot;product&quot; (notify)=&quot;onNotify()&quot;
      &gt;
  &lt;/app-product-alerts&gt;    
`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductListsComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{ 
  product = {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Phone XL&apos;</span>,
    <span class="hljs-attr">price</span>: <span class="hljs-number">799</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">&apos;A large phone with one of the best screens&apos;</span>
  },
  <span class="hljs-function"><span class="hljs-title">onNotify</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&apos;You will be notified when the product goes on sale&apos;</span>);
  }
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { }
  ngOnInit(): <span class="hljs-built_in">void</span> { }

}
</code></pre>
<h3 id="管道">管道</h3>
<p>管道的优先级要高于其他运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">管道</th>
<th style="text-align:left">详情DETAILS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/DatePipe" target="_blank"><code>DatePipe</code></a></td>
<td style="text-align:left">根据区域设置规则格式化日期值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/UpperCasePipe" target="_blank"><code>UpperCasePipe</code></a></td>
<td style="text-align:left">把文本转换成全大写形式。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/LowerCasePipe" target="_blank"><code>LowerCasePipe</code></a></td>
<td style="text-align:left">把文本转换成全小写形式。Transforms text to all lower case.</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/CurrencyPipe" target="_blank"><code>CurrencyPipe</code></a></td>
<td style="text-align:left">把数字转换成货币字符串，根据语言环境中的规则进行格式化。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/DecimalPipe" target="_blank"><code>DecimalPipe</code></a></td>
<td style="text-align:left">把数字转换成带小数点的字符串，根据语言环境中的规则进行格式化。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://angular.cn/api/common/PercentPipe" target="_blank"><code>PercentPipe</code></a></td>
<td style="text-align:left">把数字转换成百分比字符串，根据语言环境中的规则进行格式化。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>price: {{129 | currency}}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>

// $129
</code></pre>
<h3 id="导航路由">导航路由</h3>
<p>在<code>app.module.ts</code>文件中注册路由组件</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { AppRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./app-routing.module&apos;</span>;
<span class="hljs-meta">@NgModule</span>({
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-comment">/* ... */</span>
    AppRoutingModule,
    <span class="hljs-comment">/* ... */</span>
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }
</code></pre>
<p>抽离出单独的文件<code>app-routing.module.ts</code>来管理路由；</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;
<span class="hljs-keyword">import</span> { RouterModule, Routes } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/router&apos;</span>;
<span class="hljs-keyword">import</span> { ProductDetailsComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./product-details/product-details.component&apos;</span>;
<span class="hljs-keyword">import</span> { ProductListsComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./product-lists/product-lists.component&apos;</span>;


<span class="hljs-keyword">const</span> routes: Routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&apos;&apos;</span>, <span class="hljs-attr">component</span>: ProductListsComponent },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&apos;products/:productId&apos;</span>, <span class="hljs-attr">component</span>: ProductDetailsComponent },
];

<span class="hljs-meta">@NgModule</span>({
  <span class="hljs-attr">imports</span>: [RouterModule.forRoot(routes)],
  <span class="hljs-attr">exports</span>: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> </span>{ }
</code></pre>
<p>通常通过<code>RouterModule.forRoot()</code>方法来进行注册，并导出<code>RouterModule</code>来提供给其他组件使用。</p>
<p>路由的跳转和使用</p>
<blockquote>
<p><a href="http://angular.cn/guide/router-reference" target="_blank">路由参考手册</a></p>
</blockquote>
<pre><code class="lang-html">// 通过a标签的routerlink跳转，传入一个数组，为斜杠拆分后的地址栏后缀
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">&quot;[&apos;/products&apos;, product.id]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
// 还有很多用法...
</code></pre>
<h3 id="服务">服务</h3>
<p>创建一个服务，其他应用可以导入此服务，来使用其中的类型、方法。</p>
<p>导入方式一般实在构造函数中注入。像这样</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartService</span> </span>{ 
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: HttpClient</span>)</span> { }
}
</code></pre>
<h3 id="http-请求">http 请求</h3>
<p>通过全局注册Angular自身的包<code>HttpClientModule</code>，并在服务中引入<code>HttpClient</code>使用</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { HttpClient } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/common/http&apos;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartService</span> </span>{ 
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: HttpClient</span>)</span> { }
    <span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">this</span>.http.get&lt;<span class="hljs-built_in">number</span>[]&gt;(<span class="hljs-string">&apos;http:xxx.xxx/api&apos;</span>)
    }
}
</code></pre>
<h3 id="表单">表单</h3>
<ol>
<li>全局注册 <code>ReactiveFormsModule</code></li>
<li>局部引入<code>FormBuilder</code></li>
<li>创建group表单对象 <code>formBuilder.group()</code></li>
<li>书写表单</li>
</ol>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">&quot;checkoutForm&quot;</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">&quot;onSubmit()&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
    Name:
  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span>
    Address:
  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Purchase<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<h2 id="angular-基础知识">Angular 基础知识</h2>
<h3 id="视图封装-css的处理方式">视图封装-CSS的处理方式</h3>
<p><code>Component</code> 的装饰器提供了 <a href="https://angular.cn/api/core/Component#encapsulation" target="_blank"><code>encapsulation</code></a> 选项，可用来控制如何基于<em>每个组件</em>应用视图封装。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ViewEncapsulation.Emulated</code></td>
<td style="text-align:left">组件的样式会添加到文档的 <code>&lt;head&gt;</code> 中，使它们在整个应用程序中可用，但它们的选择器只会影响它们各自组件模板中的元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>ViewEncapsulation.None</code></td>
<td style="text-align:left">组件的样式会添加到文档的 <code>&lt;head&gt;</code> 中，使它们在整个应用程序中可用，因此是完全全局的，会影响文档中的任何匹配元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>ViewEncapsulation.ShadowDom</code></td>
<td style="text-align:left">组件样式仅添加到 shadow DOM 宿主中，确保它们仅影响各自组件视图中的元素。</td>
</tr>
</tbody>
</table>
<p>每一个组件都可以设置自己的封装方式，但是不建议混合封装，除非非常了解不同模式的封装行为。</p>
<h3 id="组件交互-组件通信">组件交互-组件通信</h3>
<p>除了上文提到的父组件绑定输入属性给子组件传数据，和子组件自定义事件传递给父组件传递事件和数据两种方式外。</p>
<p>下文将会详细的说明指令在父子组件通信的使用。</p>
<ol>
<li><h3 id="还可以通过setter和ngonchanges来拦截输入属性的变化，从而做一些事情，比如打日志，预处理。">还可以通过<code>setter</code>和<code>ngOnChanges()</code>来拦截输入属性的变化，从而做一些事情，比如打日志，预处理。</h3>
</li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-comment">// setter</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameChildComponent</span> </span>{ 
  <span class="hljs-meta">@Input</span>()
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>(): <span class="hljs-title">string</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name; }
  <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-built_in">this</span>._name = (name &amp;&amp; name.trim()) || <span class="hljs-string">&apos;&lt;no name set&gt;&apos;</span>;
  }
  <span class="hljs-keyword">private</span> _name = <span class="hljs-string">&apos;&apos;</span>;
}
<span class="hljs-comment">// ngOnChanges()</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameChildComponent</span> </span>{ 
  <span class="hljs-meta">@Input</span>() name : <span class="hljs-built_in">string</span>
      <span class="hljs-function"><span class="hljs-title">ngOnChanges</span>(<span class="hljs-params">changes : SimpleChanges</span>)</span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">of</span> changes){
            <span class="hljs-keyword">const</span> changeProp = changes[propName]
            <span class="hljs-keyword">const</span> to = <span class="hljs-built_in">JSON</span>.stringify(changeProp.currentValue)
            <span class="hljs-keyword">if</span>(changeProp.isFirstChanged()){
             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;初始值:&apos;</span> + to)
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">const</span> <span class="hljs-keyword">from</span> = <span class="hljs-built_in">JSON</span>.stringify(changeProp.previousVlaue)
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${propName}</span> 由<span class="hljs-subst">${<span class="hljs-keyword">from</span>}</span> 更改为<span class="hljs-subst">${to}</span>`</span>)
            }
        }
    }
}
</code></pre>
<ol>
<li><h3 id="或者通过本地变量的方式，使父组件可以访问子组件的属性和方法。">或者通过本地变量的方式，使父组件可以访问子组件的属性和方法。</h3>
</li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;app-countdown-parent-lv&apos;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;
    &lt;button type=&quot;button&quot; (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt;
    &lt;button type=&quot;button&quot; (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt;
    &lt;div class=&quot;seconds&quot;&gt;{{timer.seconds}}&lt;/div&gt;
    &lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt; 
  `</span>,
  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&apos;../assets/demo.css&apos;</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLocalVarParentComponent</span> </span>{
  <span class="hljs-comment">// 也就是这里无法访问子组件的属性和方法</span>
}
</code></pre>
<p><code>#timer</code>就是定义本地变量的方式，模板中可以直接通过<code>timer.start()</code>来访问子组件的方法，非常方便。</p>
<p>但是也有弊端，就是父组件类中的代码无法访问子组件，只能在模板中使用。</p>
<ol>
<li><h3 id="为了解决-2-的问题，viewchild可以很好的解决。将子组件通过此方式注入到父组件中即可。">为了解决 2 的问题，<code>@ViewChild</code>可以很好的解决。将子组件通过此方式注入到父组件中即可。</h3>
</li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownViewChildParentComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">AfterViewInit</span> </span>{

  <span class="hljs-meta">@ViewChild</span>(CountdownTimerComponent) <span class="hljs-comment">// 注入子组件</span>
  <span class="hljs-keyword">private</span> timerComponent!: CountdownTimerComponent; <span class="hljs-comment">// 私有变量保存</span>

  <span class="hljs-function"><span class="hljs-title">seconds</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }

  <span class="hljs-function"><span class="hljs-title">ngAfterViewInit</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.seconds = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.timerComponent.seconds, <span class="hljs-number">0</span>);
  }

  <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-built_in">this</span>.timerComponent.start(); }
  <span class="hljs-function"><span class="hljs-title">stop</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-built_in">this</span>.timerComponent.stop(); }
}
</code></pre>
<p><code>ngAfterViewInit()</code> 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0。</p>
<p>然后 Angular 会调用 <code>ngAfterViewInit</code> 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫<strong>再等一轮</strong>。</p>
<p>使用 <code>setTimeout()</code> 来等下一轮，然后改写 <code>seconds()</code> 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。</p>
<ol>
<li><h3 id="最后的，父子组件通过服务来通信">最后的，父子组件通过服务来通信</h3>
</li>
</ol>
<p>主要遵循发布-订阅模式，通过服务类的共同实例来进行任务的发布和接收。借用到<code>rxjs</code>的一些对象和类</p>
<p>父组件实例化一个服务类，并将此实例通过<code>providers</code>共享给子组件，两者就可以使用同一个实例进行通信了。</p>
<blockquote>
<p>详细的和具体代码<a href="https://angular.cn/guide/component-interaction#parent-and-children-communicate-using-a-service" target="_blank">看这里</a></p>
</blockquote>
<p>2022-7-4</p>
<hr>
<h3 id="指令">指令</h3>
<ul>
<li><code>@Input</code>
<img src="https://i.jpg.dog/file/jpg-dog/6cf7002982c4a70ebcb23e66ff4fcd78.png" alt="6cf7002982c4a70ebcb23e66ff4fcd78.png"></li>
</ul>
<p><code>[item]</code>即为子组件通过<code>input</code>定义的输入属性，父组件通过赋值将自己的数据传递给子组件的<code>item</code></p>
<ul>
<li><code>@Output</code></li>
</ul>
<p>Output所定义的事件必须是<code>EventEmitter</code>类型的；传给父组件的数据是通过形参<code>$event</code>获取的；父组件必须有相应的函数方法来应对、绑定子组件的自定义事件。</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { Output, EventEmitter } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span> </span>{
  <span class="hljs-meta">@Output</span>() newItemEvent = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;();

  <span class="hljs-function"><span class="hljs-title">addNewItem</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">this</span>.newItemEvent.emit(value);
  }
}
<span class="hljs-comment">// 父组件</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;parrent-component&apos;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt;`</span>,
  <span class="hljs-comment">/* ... */</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span></span>{
  items = [<span class="hljs-string">&apos;item1&apos;</span>, <span class="hljs-string">&apos;item2&apos;</span>, <span class="hljs-string">&apos;item3&apos;</span>, <span class="hljs-string">&apos;item4&apos;</span>];
  <span class="hljs-function"><span class="hljs-title">addItem</span>(<span class="hljs-params">newItem: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">this</span>.items.push(newItem);
  }
}
</code></pre>
<ul>
<li>同时使用两者
<img src="https://i.jpg.dog/file/jpg-dog/e527a4d827eb6de516701b38f8690f13.png" alt="e527a4d827eb6de516701b38f8690f13.png">
​    </li>
</ul>
<pre><code class="lang-mermaid">graph LR;
    父组件 --数据--&gt; 子组件
    子组件 --事件--&gt; 父组件
</code></pre>
<h3 id="简单的内容投影">简单的内容投影</h3>
<p>通过<code>&lt;ng-content&gt;</code>元素进行投影，大致的使用方法有两种</p>
<ol>
<li>单插槽</li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-comment">// 被投影组件</span>
<span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;app-zippy-basic&apos;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;h2&gt;Single-slot content projection&lt;/h2&gt;
    &lt;ng-content&gt;&lt;/ng-content&gt;
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZippyBasicComponent</span> </span>{}

<span class="hljs-comment">// 投影内容</span>
<span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;app-zippy-content&apos;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
      &lt;app-zippy-basic&gt;
          &lt;p&gt;我是投影的内容&lt;/p&gt;
      &lt;/app-zippy-basic&gt;
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZippyContentComponent</span> </span>{}
</code></pre>
<ol>
<li>多插槽-有名字的投影</li>
</ol>
<p><code>select</code>属性强大之处在于遵循CSS选择器的规则，可以像写CSS选择器一样，去给插槽分配选择器</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// 被投影组件</span>

  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;h2&gt;Single-slot content projection&lt;/h2&gt;
    &lt;ng-content select=&quot;[question]&quot;&gt;&lt;/ng-content&gt;
    &lt;ng-content select=&quot;#oneId&quot;&gt;&lt;/ng-content&gt;
    &lt;ng-content select=&quot;.oneClass&quot;&gt;&lt;/ng-content&gt;
    &lt;ng-content select=&quot;p&quot;&gt;&lt;/ng-content&gt;
    &lt;ng-content&gt;&lt;/ng-content&gt;
  `</span>
<span class="hljs-comment">// 投影内容</span>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
      &lt;app-zippy-basic&gt;
          &lt;div&gt;我是默认的投影内容&lt;/div&gt;
          &lt;p questiopn&gt;我是投影question的内容&lt;/p&gt;
          &lt;p id=&quot;oneId&quot;&gt;我是投影#oneId的内容&lt;/p&gt;
          &lt;p class=&quot;oneClass&quot;&gt;我是投影.oneClass的内容&lt;/p&gt;
          &lt;p&gt;我是投影p的内容&lt;/p&gt;
      &lt;/app-zippy-basic&gt;
  `</span>
</code></pre>
<ol>
<li>更为复杂的<code>&lt;ng-container&gt;</code> 和<code>&lt;ng-template&gt;</code>标签实现内容投影，在日后再进行完善。</li>
</ol>
<h3 id="部分模板语法">部分模板语法</h3>
<p>绑定元素的<code>Property</code>属性</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> [<span class="hljs-attr">jasonk</span>]=<span class="hljs-string">&quot;jasonkValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p>绑定元素的<code>Attribute</code>属性</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> [<span class="hljs-attr">attr.aria-label</span>]=<span class="hljs-string">&quot;xxxName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> // 绑定ariaLabel
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">attr.aria-hidden</span>]=<span class="hljs-string">&quot;isHidden&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 绑定ariaHidden
</code></pre>
<p>绑定元素的类</p>
<table>
<thead>
<tr>
<th style="text-align:left">绑定类型</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">输入属性</th>
<th style="text-align:left">范例输入值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单一类绑定</td>
<td style="text-align:left"><code>[class.sale]=&quot;onSale&quot;</code></td>
<td style="text-align:left">`boolean</td>
<td style="text-align:left">undefined</td>
<td>null`</td>
<td><code>true</code>, <code>false</code></td>
</tr>
<tr>
<td style="text-align:left">多重类绑定</td>
<td style="text-align:left"><code>[class]=&quot;classExpression&quot;</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"><code>&quot;my-class-1 my-class-2 my-class-3&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">多重类绑定</td>
<td style="text-align:left"><code>[class]=&quot;classExpression&quot;</code></td>
<td style="text-align:left">`Record&lt;string, boolean</td>
<td style="text-align:left">undefined</td>
<td>null&gt;`</td>
<td><code>{foo: true, bar: false}</code></td>
</tr>
<tr>
<td style="text-align:left">多重类绑定</td>
<td style="text-align:left"><code>[class]=&quot;classExpression&quot;</code></td>
<td style="text-align:left"><code>Array&lt;string&gt;</code></td>
<td style="text-align:left"><code>[&apos;foo&apos;, &apos;bar&apos;]</code></td>
</tr>
</tbody>
</table>
<p>绑定元素的样式</p>
<table>
<thead>
<tr>
<th style="text-align:left">绑定类型</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">输入属性</th>
<th style="text-align:left">范例输入值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单一样式绑定</td>
<td style="text-align:left"><code>[style.width]=&quot;width&quot;</code></td>
<td style="text-align:left">`string</td>
<td style="text-align:left">undefined</td>
<td>null`</td>
<td><code>&quot;100px&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">带单位的单一样式绑定</td>
<td style="text-align:left"><code>[style.width.px]=&quot;width&quot;</code></td>
<td style="text-align:left">`number</td>
<td style="text-align:left">undefined</td>
<td>null`</td>
<td><code>100</code></td>
</tr>
<tr>
<td style="text-align:left">多重样式绑定</td>
<td style="text-align:left"><code>[style]=&quot;styleExpression&quot;</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"><code>&quot;width: 100px; height: 100px&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">多重样式绑定</td>
<td style="text-align:left"><code>[style]=&quot;styleExpression&quot;</code></td>
<td style="text-align:left">`Record&lt;string, string</td>
<td style="text-align:left">undefined</td>
<td>null&gt;`</td>
<td><code>{width: &apos;100px&apos;, height: &apos;100px&apos;}</code></td>
</tr>
</tbody>
</table>
<p>绑定事件</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;onSave()&quot;</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;clickMessage=$event&quot;</span>&gt;</span>
    点击出现click信息
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>{{clickMessage}}
</code></pre>
<h3 id="模板变量">模板变量</h3>
<ul>
<li><p>当在某个元素中声明了模板变量，那么此元素的DOM实例将会被赋值给该模板变量。</p>
</li>
<li><p>模板变量相当于声明了一个变量<code>let xxx = 123</code>，它具有自己的作用域，和<code>javascript</code>的作用域没有区别。</p>
</li>
<li><p>如果在模板变量右侧指定一个名字，那么该模板变量就会引用所在元素上具有这个 <code>exportAs</code> 名字的指令或组件。这通常运用在表单中。</p>
</li>
</ul>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> #<span class="hljs-attr">itemForm</span>=<span class="hljs-string">&quot;ngForm&quot;</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">&quot;onSubmit(itemForm)&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">ngModel</span> <span class="hljs-attr">required</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">hidden</span>]=<span class="hljs-string">&quot;!itemForm.form.valid&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ submitMessage }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>​        模板变量<code>itemForm</code>指向<code>ngForm</code>（这是由FormsModule导入的，规范化的Form实例，方便使用和管理），可以直接在提交和下方信息展示中直接使用模板变量读取数据。</p>
<ul>
<li><a href="https://angular.cn/guide/template-reference-variables" target="_blank">模板输入变量</a>(不是很理解，先放这里)</li>
</ul>
<h3 id="内置指令">内置指令</h3>
<h4 id="内置属性型指令">内置属性型指令</h4>
<ul>
<li><p>ngClass区别于上述的类绑定，内置指令多与表达式和方法搭配使用，来增删动态的（响应式的）类。</p>
</li>
<li><p>ngStyle区别于上述的样式绑定 ，同上。</p>
</li>
<li><p>ngModel用于表单的双向绑定。需要导入<a href="https://angular.cn/api/forms/FormsModule" target="_blank"><code>FormsModule</code></a> ，并全局注册（在NgModule中注册），然后直接使用。</p>
</li>
</ul>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;example-ngModel&quot;</span>&gt;</span>[(ngModel)]:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;currentItem.name&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-ngModel&quot;</span>&gt;</span>
</code></pre>
<p>其原理和更复杂用法（获取值并同步的做其他处理...）看<a href="https://angular.cn/api/forms/NgModel" target="_blank">官网这里</a></p>
<h4 id="内置结构性指令">内置结构性指令</h4>
<table>
<thead>
<tr>
<th style="text-align:left">常见的内置结构型指令</th>
<th style="text-align:left">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://angular.cn/guide/built-in-directives#ngIf" target="_blank"><code>NgIf</code></a></td>
<td style="text-align:left">有条件地从模板创建或销毁子视图。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://angular.cn/guide/built-in-directives#ngFor" target="_blank"><code>NgFor</code></a></td>
<td style="text-align:left">为列表中的每个条目重复渲染一个节点。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://angular.cn/guide/built-in-directives#ngSwitch" target="_blank"><code>NgSwitch</code></a></td>
<td style="text-align:left">一组在备用视图之间切换的指令。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>特别需要注意的是： <a href="https://angular.cn/guide/structural-directives#one-per-element" target="_blank">每个元素只能有一个结构型指令</a></strong></p>
</blockquote>
<ul>
<li>NgFor</li>
</ul>
<p>全部的写法，另外，<code>NgIf</code>需要包裹<code>NgFor</code>，当需要同时使用两者时。</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let item of items; let i=index; trackBy: trackByItems&quot;</span>&gt;</span>{{i + 1}} - {{item.name}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="lang-typescript">trackByItems(index: <span class="hljs-built_in">number</span>, <span class="hljs-attr">item</span>: Item): <span class="hljs-built_in">number</span> { <span class="hljs-keyword">return</span> item.id; }
</code></pre>
<p>关于<code>trackBy</code>，加上追踪根据后，有助于DOM更新时对旧DOM的复用，提高性能。</p>
<p>当上述的语句解析完之后，会变成下边这样</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">ngFor</span> <span class="hljs-attr">let-item</span> [<span class="hljs-attr">NgForOf</span>]=<span class="hljs-string">&quot;items&quot;</span> <span class="hljs-attr">let-i</span>=<span class="hljs-string">&quot;index&quot;</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {{i + 1}} - {{item.name}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
</code></pre>
<p><a href="https://angular.cn/api/common/NgForOf#description" target="_blank"><code>*NgFor</code>的API</a></p>
<ul>
<li>NgSwitch</li>
</ul>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngSwitch</span>]=<span class="hljs-string">&quot;currentItem.feature&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&apos;bright&apos;&quot;</span>&gt;</span> Are you as bright as {{currentItem.name}}?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&apos;vintage&apos;&quot;</span>&gt;</span> Are you as bright as {{currentItem.name}}?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchDefault</span> &gt;</span> Are you as bright as {{currentItem.name}}?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left"><code>NGSWITCH</code> 指令</th>
<th style="text-align:left">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>NgSwitch</code></td>
<td style="text-align:left">一个属性型指令，会更改其伴生指令的行为。</td>
</tr>
<tr>
<td style="text-align:left"><code>NgSwitchCase</code></td>
<td style="text-align:left">当其绑定值等于开关值时将其元素添加到 DOM 中，而在其不等于开关值时将其绑定值移除。</td>
</tr>
<tr>
<td style="text-align:left"><code>NgSwitchDefault</code></td>
<td style="text-align:left">当没有选中的 <code>NgSwitchCase</code> 时，将其宿主元素添加到 DOM 中。</td>
</tr>
</tbody>
</table>
<p> 2022.7.5</p>
<hr>
<h2 id="《英雄之旅》实战总结">《英雄之旅》实战总结</h2>
<h3 id="observable和subject"><code>Observable</code>和<code>Subject</code></h3>
<p>他们来自<code>Rxjs</code>，前者是可观察对象，后者是一种特殊的可观察对象</p>
<p>通常可观察对象都只能通知单一的订阅（观察）者，而<code>Subject</code>可以将值通知到多个订阅（观察）者。</p>
<p>我们可以通过<code>next()</code>方法向<code>Subject</code>中推入新的值，而后<code>Subject</code>就会将值推送给订阅者们。</p>
<h4 id="of"><code>of</code></h4>
<p>如果我们需要主动使用<code>Observable</code>对象，我们可以使用<code>of()</code>方法将普通对象转化为<code>Observable</code>对象</p>
<p>此方法来自<code>Rxjs</code></p>
<h3 id="增删改查">增删改查</h3>
<p>通过全局引入并注册<code>HttpClientModule</code>模块，我们可以在组件中引入并使用<code>HttpClient, HttpHeaders</code>两个类；</p>
<p><code>HttpClient</code>通过他们的get、put、post、delete方法来进行增删改查以及搜索的实现。值得一提的是，方法本身返回的就是一个<code>Observable</code>对象，以供订阅和打上异步签名。</p>
<p><code>HttpHeaders</code>可以提供统一的http头部设置。</p>
<pre><code class="lang-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">heroService</span></span>{  
    <span class="hljs-comment">// 通过get获取列表</span>
    getHero(id:<span class="hljs-built_in">number</span>): Observable&lt;Hero&gt;{
        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.heroesUrl}</span>/<span class="hljs-subst">${id}</span>`</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero&gt;(url).pipe(
              tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`来自英雄服务：找到一条英雄数据id=<span class="hljs-subst">${id}</span>`</span>)),
              catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">`getHero id=<span class="hljs-subst">${id}</span>`</span>)))
      }
    <span class="hljs-comment">// 通过post新增一条记录</span>
    addHero(hero: Hero): Observable&lt;Hero&gt;{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.post&lt;Hero&gt;(<span class="hljs-built_in">this</span>.heroesUrl, hero, <span class="hljs-built_in">this</span>.httpOptions).pipe(
          tap(<span class="hljs-function"><span class="hljs-params">newHero</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`新增了一位英雄<span class="hljs-subst">${newHero.id}</span>`</span>)),
         catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">`addHero fail`</span>)))
      }
       <span class="hljs-comment">// 通过get进行搜索</span>
    searchHero(term: <span class="hljs-built_in">string</span>): Observable&lt;Hero[]&gt;{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.heroesUrl}</span>/?name=<span class="hljs-subst">${term}</span>`</span>).pipe(
          tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> _.length ? 
            <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`找到了匹配“<span class="hljs-subst">${term}</span>”的英雄`</span>) :
             <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`没有匹配“<span class="hljs-subst">${term}</span>”的英雄`</span>)
              ),
          catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">&apos;searchHeroes&apos;</span>, [])))
      }
    <span class="hljs-comment">// put修改、delete删除，</span>
}
</code></pre>
<p>可以发现，都使用到了<code>pipe</code>，这个东西可以帮助我们进行返回值的处理，如果报错了，我们可以返回一个安全值以免系统的崩溃。</p>
<p><code>tap()</code>也是来自<code>Rxjs</code>，它可以窥探<code>Observable</code>数据流中的数据，并传出来做一些事情，且不改变值本身。方便我们做一些处理和记录。</p>
<p>在我们使用<code>Observable</code>对象的时候（我们就是<code>Observer</code>），我们需要像这样去订阅。当可观察对象发生值的变动，就会通知订阅者也就是<code>Observer</code></p>
<pre><code class="lang-typescript"><span class="hljs-function"><span class="hljs-title">getHeroes</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.heroService.getHeroes()
      .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes.slice(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))
  }
</code></pre>
<h3 id="标准的错误处理">标准的错误处理</h3>
<p>在异步请求中，我们需要对错误进行接收、处理，一个较为标准的错误处理方法是这样的</p>
<pre><code class="lang-typescript">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">heroService</span></span>{   
    handleError&lt;T&gt;(operation = <span class="hljs-string">&apos;operation&apos;</span>, result?: T) {
         <span class="hljs-keyword">return</span> (error: <span class="hljs-built_in">any</span>): Observable&lt;T&gt; =&gt; {
            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send the error to remote logging infrastructure</span>
            <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// log to console instead</span>

            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> better job of transforming error for user consumption</span>
            <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`<span class="hljs-subst">${operation}</span> failed: <span class="hljs-subst">${error.message}</span>`</span>);

            <span class="hljs-comment">// Let the app keep running by returning an empty result.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>(result <span class="hljs-keyword">as</span> T);
          };
      }
}
</code></pre>
<p>其中<code>operation</code>是指明什么操作，<code>result</code>是指明可能的结果或返回值。</p>
<h3 id="形如xxxid的路由使用">形如<code>/xxx/:id</code>的路由使用</h3>
<p>首先是配置路由与组件</p>
<p>在组件内通过引入<code>ActivatedRoute</code>模块，如以下代码那样读取<code>id</code>的值，然后查找到该条记录，并展示；其中我们可以通过发送请求的方式查找记录，也可以在本地缓存中查找记录。</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { ActivatedRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/router&apos;</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">component</span></span>{
    <span class="hljs-function"><span class="hljs-title">getHero</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">this</span>.activatedRoute.snapshot.paramMap.get(<span class="hljs-string">&apos;id&apos;</span>)
        <span class="hljs-built_in">this</span>.heroService.getHero(<span class="hljs-built_in">Number</span>(id)).subscribe(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> <span class="hljs-built_in">this</span>.hero = hero)
      }
}
</code></pre>
<h3 id="in-memory-webapi-服务"><code>In-Memory-Web</code>API 服务</h3>
<p>内存Web API，它可以模拟数据服务器</p>
<ol>
<li>安装<code>npm install angular-in-memory-web-api --save</code></li>
<li>安装之后需要全局引入并注册<code>HttpClientInMemoryWebApiModule</code>模块</li>
</ol>
<pre><code class="lang-typescript">
<span class="hljs-meta">@NgModule</span>({
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-attr">imports</span>:[
      HttpClientInMemoryWebApiModule.forRoot(
          InMemoryDataService, { <span class="hljs-attr">dataEncapsulation</span>: <span class="hljs-literal">false</span> }
         )
    ],
    <span class="hljs-comment">/* ... */</span>
})
</code></pre>
<ol>
<li>接下来创建内存Web服务，并在其中编写初始数据，像这样：</li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;
<span class="hljs-keyword">import</span> { Hero } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./hero&apos;</span>;
<span class="hljs-meta">@Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&apos;root&apos;</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryDataService</span> </span>{
 <span class="hljs-function"><span class="hljs-title">createDb</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> heroes = [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Dr. Nice&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">13</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Bombasto&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Celeritas&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Magneta&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;RubberMan&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Dynama&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Dr. IQ&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">19</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Magma&apos;</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;Tornado&apos;</span> }
    ];
    <span class="hljs-keyword">return</span> {heroes};
 }
  genId(heroes: Hero[]): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> heroes.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.max(...heroes.map(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> hero.id)) + <span class="hljs-number">1</span> : <span class="hljs-number">11</span>;
  }
<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { }

}
</code></pre>
<p>他会自动响应http的请求。也就是上述增删改查中的<code>httpClient</code>一些方法。</p>
<h3 id="搜索功能">搜索功能</h3>
<p><code>ngOnInit()</code> 往 <code>searchTerms</code> 这个可观察对象的处理管道中加入了一系列 RxJS 操作符，用以缩减对 <code>searchHeroes()</code> （搜索服务）的调用次数，并最终返回一个可及时给出英雄搜索结果的可观察对象（每次都是 <code>Hero[]</code>）。</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// 用到了三个Rxjs的操作符来降低对搜索服务的调用次数</span>
<span class="hljs-built_in">this</span>.heroes$ = <span class="hljs-built_in">this</span>.searchTerms.pipe(
  <span class="hljs-comment">// wait 300ms after each keystroke before considering the term</span>
  debounceTime(<span class="hljs-number">300</span>),

  <span class="hljs-comment">// ignore new term if same as previous term</span>
  distinctUntilChanged(),

  <span class="hljs-comment">// switch to new search observable each time the term changes</span>
  switchMap(<span class="hljs-function">(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">this</span>.heroService.searchHeroes(term)),
);
</code></pre>
<ul>
<li>在传出最终字符串之前，<code>debounceTime(300)</code> 将会等待，直到新增字符串的事件暂停了 300 毫秒。你实际发起请求的间隔永远不会小于 300ms。</li>
<li><code>distinctUntilChanged()</code> 会确保只在过滤条件变化时才发送请求。</li>
<li><code>switchMap()</code> 会为每个从 <code>debounce()</code> 和 <code>distinctUntilChanged()</code> 中通过的搜索词调用搜索服务。它会取消并丢弃以前的搜索可观察对象，只保留最近的。</li>
</ul>
<h3 id="约定"><code>$</code>约定</h3>
<p>当我们给一个属性或变量，加上一个<code>$</code>后缀，就表示 该属性是一个 <code>Observable</code> 而不是数组。</p>
<h3 id="管道async可以自动订阅observable对象">管道<code>async</code>可以自动订阅<code>Observable</code>对象</h3>
<p>由于 <code>*ngFor</code> 不能直接使用 <code>Observable</code>，所以要使用一个管道字符（<code>|</code>），后面紧跟着一个 <code>async</code>。这表示 Angular 的 <code>AsyncPipe</code> 管道，它会自动订阅 <code>Observable</code>，这样你就不用在组件类中这么做了。</p>
<hr>
<p>2022.7.6</p>
<ol>
<li>实战了《英雄之旅》，增删改查，http请求，</li>
<li>总结了一下。</li>
<li>了解了一下Rxjs的Subject和Observable对象。</li>
</ol>
<hr>
<ol>
<li>比较难的知识点，依赖注入，表单，安全，动画等等做最佳实践</li>
<li>蚂蚁的组件库，实战一下</li>
</ol>
<h2 id="深入angular">深入Angular</h2>
<h3 id="依赖注入">依赖注入</h3>
<p>通过<code>Angular CLI</code>来创建通用的服务<code>ng generate service &lt;service-name&gt;</code></p>
<p>可以在组件中注入这些服务来使用，也可以在服务中注入另一个服务形成依赖。</p>
<p>依赖注入分为两种《元素注入器》（ElementInjector）和《模块注入器》（ModuleInjector），它们在依赖注入时的顺序如图。</p>
<p><img src="https://segmentfault.com/img/remote/1460000040807837/view" alt="preview"></p>
<h4 id="几种依赖注入提供者的配置方式：">几种依赖注入提供者的配置方式：</h4>
<p>基本的模块注入器</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  <span class="hljs-attr">providers</span>: [
    <span class="hljs-comment">// 模块注入器</span>
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> </span>{}
</code></pre>
<p>基本的元素注入器，提供者为组件</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">providers</span>: [
    <span class="hljs-comment">// 元素注入器 - 组件</span>
  ]，
  <span class="hljs-attr">viewProviders</span>: [
    <span class="hljs-comment">// 元素注入器- 组件视图</span>
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{}
</code></pre>
<p>基本的元素注入器，提供者为指令</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({
  <span class="hljs-attr">providers</span>: [
   <span class="hljs-comment">// 元素注入器 - 指令</span>
 ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDirective</span> </span>{}
</code></pre>
<p>模块注入器，提供者是根模块，通常是单例的</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Injectable</span>({
 <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&apos;root&apos;</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{}
</code></pre>
<p>模块注入器，提供者是根模块，且以工厂模式来提供实例。</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MY_INJECT_TOKEN = <span class="hljs-keyword">new</span> InjectionToken&lt;MyClass&gt;(<span class="hljs-string">&apos;my-inject-token&apos;</span>, {
 <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&apos;root&apos;</span>,
 <span class="hljs-attr">factory</span>: <span class="hljs-function">() =&gt;</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass();
 }
});
</code></pre>
<h4 id="各种装饰器">各种装饰器</h4>
<ul>
<li>@Host() 来限制冒泡</li>
<li>@Self() 限制为元素自身</li>
<li>@SkipSelf() 限制为元素自身以上</li>
<li>@Optional() 标记为可选</li>
<li>@Inject() 限制为自定义Token令牌</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3c37835fb4743f381cc8823350769b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图3.png"></p>
<h3 id="变更检测">变更检测</h3>
<h4 id="区域污染">区域污染</h4>
<p><strong>Zone.js</strong>是一种信号机制，Angular 用它来检测应用程序状态何时可能已更改。它捕获异步操作，比如 <code>setTimeout</code>、网络请求和事件侦听器。Angular 会根据来自 Zone.js 的信号安排变更检测</p>
<p>但是有些时候，一些频繁的但是不会对数据模型发生变更的操作，会造成性能的浪费（区域污染），所以我们需要让他们跳出<code>NgZone</code>。</p>
<blockquote>
<p> 比如<code>requestAnimationFrame</code> 、 <code>setTimeout</code> 或 <code>setInterval</code>以及第三方库的任务或微任务调度</p>
</blockquote>
<p>在 NgZone 之外运行任务：使用此方法<code>runOutsideAngular</code></p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Component, NgZone, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;
<span class="hljs-meta">@Component</span>(...)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> ngZone: NgZone</span>)</span> {}
  <span class="hljs-function"><span class="hljs-title">ngOnInit</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.ngZone.runOutsideAngular(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setInterval</span>(pollForUpdates), <span class="hljs-number">500</span>);
  }
}
</code></pre>
<h4 id="跳过组件子树">跳过组件子树</h4>
<p>在组件中进行如下设置，就可以让该组件及其子组件，跳过默认的变更检测，使用<code>onPush</code>策略</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { ChangeDetectionStrategy, Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/core&apos;</span>;
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">changeDetection</span>: ChangeDetectionStrategy.OnPush,
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{}
</code></pre>
<p><code>onPush</code>策略会在以下两种情况下才运行变更检测</p>
<ul>
<li>子树的根组件接收到作为模板绑定的结果的新输入。Angular 将输入的当前值和过去值使用 <code>==</code> 进行比较</li>
<li>Angular 处理使用了 OnPush 变更检测策略的组件中的事件时</li>
</ul>
<p><code>onPush</code>策略的<code>MainComponent</code>面临非本组件的事件的时候，并不会触发变更检测(包括其子组件)</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/ea34be569ec4265adb2d4f57c6df3e9f.png" alt="ea34be569ec4265adb2d4f57c6df3e9f.png"></p>
<p><code>onPush</code>策略的<code>MainComponent</code>面临自己的事件的时候就会触发变更检测，此时其默认策略的子组件也会触发变更检测，而<code>onPush</code>策略的子组件<code>LoginComponent</code>并不会发出发变更检测，因为事件不发生在它的内部</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/888eb645be19b0bbaa38dced7e5589d2.png" alt="888eb645be19b0bbaa38dced7e5589d2.png"></p>
<p>面对新的输入和事件是相同的处理方式，和情况
<img src="https://i.jpg.dog/file/jpg-dog/a9761f40faa44563d819237e4543f3b1.png" alt="a9761f40faa44563d819237e4543f3b1.png"></p>
<h4 id="值得特别注意的是">值得特别注意的是</h4>
<blockquote>
<ul>
<li><strong>修改对象引用</strong>。如果输入接收到可变对象作为值，并且你修改了对象内容但引用没变，则 Angular 将不会调用变更检测。这是预期的行为，因为输入的前一个值和当前值都指向了同一个引用。</li>
<li><strong>修改 TypeScript 代码中的输入属性</strong>。当你使用 <code>@ViewChild</code> 或 <code>@ContentChild</code> 等 API 来获取对 TypeScript 中组件的引用并手动修改 <code>@Input</code> 属性时，Angular 将不会自动为 OnPush 组件运行变更检测。如果你需要 Angular 运行变更检测，你可以在你的组件中注入 <code>ChangeDetectorRef</code> 并调用 <code>changeDetectorRef.markForCheck()</code> 来告诉 Angular 为其安排一次变更检测。（<strong>这个看不懂</strong>）</li>
</ul>
</blockquote>
<h3 id="国际化">国际化</h3>
<p><em>国际</em>化，有时称为 i18n，是设计和准备项目，以便在世界各地的不同语言环境使用的过程。<em>本地化</em>是为不同的语言环境构建项目版本的过程。本地化过程包括以下操作。</p>
<ul>
<li>提取文本以翻译成不同的语言</li>
<li>格式化特定语言环境的数据</li>
</ul>
<p><em>语言环境</em>标识人们使用特定语言或语言变体的区域。可能的区域包括国家和地理区域。语言环境决定了以下详细信息的格式和解析。</p>
<ul>
<li>度量单位，包括日期和时间、数字和货币</li>
<li>翻译名称，包括时区、语言和国家</li>
</ul>
<p>：TODO</p>
<h3 id="动画">动画</h3>
<p>简单来说。就是可以定义几种状态，然后在状态之间切换的时候，分别设置运动动画和效果。</p>
<p>小栗子：飞入飞出的动画设置。</p>
<p>设置一个状态<code>in</code>只有在里边和不在里边（dom元素已经被删除）两种状态，</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// src/app/heroes.component.ts</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&apos;app-heroes&apos;</span>, 
  <span class="hljs-attr">animations</span>: [
    trigger(<span class="hljs-string">&apos;flyInOut&apos;</span>, [
      <span class="hljs-comment">// ...</span>
      state(<span class="hljs-string">&apos;in&apos;</span>, style( {<span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(0)&apos;</span>})),
      transition(<span class="hljs-string">&apos;void =&gt; *&apos;</span>, [ <span class="hljs-comment">// 进来时从左边飞进来</span>
        style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(-100%)&apos;</span> }),
        animate(<span class="hljs-number">200</span>)
      ]),
      transition(<span class="hljs-string">&apos;* =&gt; void&apos;</span>, [ <span class="hljs-comment">// 出去时从右边飞出去</span>
        animate(<span class="hljs-number">300</span>, style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(100vw)&apos;</span> }))

      ]),
    ]),
  ],
})
<span class="hljs-comment">// src/app/heroes.component.html</span>
<span class="hljs-comment">/* ... */</span>
<span class="hljs-string">`
&lt;button (click)=&quot;toggle()&quot;&gt;Toggle&lt;/button&gt;
&lt;div *ngIf=&quot;isIn&quot; 
    [@flyInOut]=&quot;isIn&quot; &gt;
    &lt;p&gt;这个元素的状态{{isIn}}&lt;/p&gt;
&lt;/div&gt;
`</span>
<span class="hljs-comment">/* ... */</span>
</code></pre>
<p>需要注意的一点是，<code>style</code>方法的使用位置，在<code>animate</code>前边指的是，先设置目标状态，再通过动画过渡。如果使用以下的顺序，那么出去的时候，就会从右边飞过来</p>
<pre><code class="lang-typescript"> animations: [
    trigger(<span class="hljs-string">&apos;flyInOut&apos;</span>, [
      <span class="hljs-comment">// ...</span>
      state(<span class="hljs-string">&apos;in&apos;</span>, style( {<span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(0)&apos;</span>})),
      transition(<span class="hljs-string">&apos;void =&gt; *&apos;</span>, [ <span class="hljs-comment">// 进来时从左边飞进来</span>
        style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(-100%)&apos;</span> }),
        animate(<span class="hljs-number">200</span>)
      ]),
      transition(<span class="hljs-string">&apos;* =&gt; void&apos;</span>, [ <span class="hljs-comment">// 出去时从右边飞出去</span>
        style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(100vw)&apos;</span> })
        animate(<span class="hljs-number">300</span>)
      ]),
    ]),
  ],
</code></pre>
<h4 id> </h4>
<h4 id="enter-和-leave-别名">:enter 和 :leave 别名</h4>
<p><code>:enter</code> 和 <code>:leave</code> 分别是 <code>void =&gt; *</code> 和 <code>* =&gt; void</code> 的别名。这些别名供多个动画函数使用。</p>
<h4 id="转场中的-increment-和-decrement">转场中的 <code>:increment</code> 和 <code>:decrement</code></h4>
<p><code>transition()</code> 函数还能接受额外的选择器值：<code>:increment</code> 和 <code>:decrement</code>。当数值增加或减小时，使用这些来启动转场。</p>
<p>这个例子使用了<code>query</code>和<code>stagger</code></p>
<pre><code class="lang-typescript">trigger(<span class="hljs-string">&apos;filterAnimation&apos;</span>, [
  transition(<span class="hljs-string">&apos;:enter, * =&gt; 0, * =&gt; -1&apos;</span>, []),
  transition(<span class="hljs-string">&apos;:increment&apos;</span>, [
    query(<span class="hljs-string">&apos;:enter&apos;</span>, [
      style({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">0</span> }),
      stagger(<span class="hljs-number">50</span>, [
        animate(<span class="hljs-string">&apos;300ms ease-out&apos;</span>, style({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">width</span>: <span class="hljs-string">&apos;*&apos;</span> })),
      ]),
    ], { <span class="hljs-attr">optional</span>: <span class="hljs-literal">true</span> })
  ]),
  transition(<span class="hljs-string">&apos;:decrement&apos;</span>, [
    query(<span class="hljs-string">&apos;:leave&apos;</span>, [
      stagger(<span class="hljs-number">50</span>, [
        animate(<span class="hljs-string">&apos;300ms ease-out&apos;</span>, style({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">0</span> })),
      ]),
    ])
  ]),
]),
</code></pre>
<h4 id="复杂的动画序列函数">复杂的动画序列函数</h4>
<p>用来控制复杂动画序列的函数如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>query()</code></td>
<td style="text-align:left">用于查找一个或多个内部 HTML 元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>stagger()</code></td>
<td style="text-align:left">用于为多元素动画应用级联延迟。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://angular.cn/api/animations/group" target="_blank"><code>group()</code></a></td>
<td style="text-align:left">用于并行执行多个动画步骤。</td>
</tr>
<tr>
<td style="text-align:left"><code>sequence()</code></td>
<td style="text-align:left">用于逐个顺序执行多个动画步骤。</td>
</tr>
</tbody>
</table>
<h4 id="可复用动画">可复用动画</h4>
<p>我们将上述的小栗子提取出来，做成可以复用的动画</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// src/app/</span>
<span class="hljs-keyword">import</span> { animate, state, style, transition, trigger } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/animations&apos;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> flyInOut = trigger(<span class="hljs-string">&apos;flyInOut&apos;</span>, [
      <span class="hljs-comment">// ...</span>
      state(<span class="hljs-string">&apos;true&apos;</span>, style( {<span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(0)&apos;</span>})),
      transition(<span class="hljs-string">&apos;void =&gt; *&apos;</span>, [
        style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(-100%)&apos;</span> }),
        animate(<span class="hljs-number">200</span>)
      ]),
      transition(<span class="hljs-string">&apos;* =&gt; void&apos;</span>, [
        animate(<span class="hljs-number">300</span>, style({ <span class="hljs-attr">transform</span>: <span class="hljs-string">&apos;translateX(100vw)&apos;</span> }))
      ]),
 ])
<span class="hljs-comment">// ....ts</span>
<span class="hljs-meta">@Component</span>({
    <span class="hljs-attr">animations</span>: flyInOut,
})
<span class="hljs-comment">// ....html</span>
<span class="hljs-string">`&lt;div [@flyInOut]&gt;&lt;/div&gt;`</span>
</code></pre>
<p>如果元素本身可以删除和新增，那么就不需要绑定输入值；如果没办法删除、新增，也就没有状态转换了，需要和<code>*NgIf</code>搭配的使用。</p>
<h4 id="路由动画">路由动画</h4>
<p>做出来一个动画，这边是一个模板样例：(路由的<code>data</code>属性需要和状态名字保持统一，如<code>HeroesLists</code>、<code>DashBoard</code>)</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { trigger, transition, style, query, animateChild, group, animate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@angular/animations&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> slideInAnimation =
  trigger(<span class="hljs-string">&apos;routeAnimations&apos;</span>, [
    transition(<span class="hljs-string">&apos;HeroesLists &lt;=&gt; DashBoard&apos;</span>, [
      style({ <span class="hljs-attr">position</span>: <span class="hljs-string">&apos;relative&apos;</span> }),
      query(<span class="hljs-string">&apos;:enter, :leave&apos;</span>, [
        style({
          <span class="hljs-attr">position</span>: <span class="hljs-string">&apos;absolute&apos;</span>,
          <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">width</span>: <span class="hljs-string">&apos;100%&apos;</span>
        })
      ]),
      query(<span class="hljs-string">&apos;:enter&apos;</span>, [
        style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;-100%&apos;</span> })
      ]),
      query(<span class="hljs-string">&apos;:leave&apos;</span>, animateChild()),
      group([
        query(<span class="hljs-string">&apos;:leave&apos;</span>, [
          animate(<span class="hljs-string">&apos;300ms ease-out&apos;</span>, style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;100%&apos;</span> }))
        ]),
        query(<span class="hljs-string">&apos;:enter&apos;</span>, [
          animate(<span class="hljs-string">&apos;300ms ease-out&apos;</span>, style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;0%&apos;</span> }))
        ]),
      ]),
    ]),
    transition(<span class="hljs-string">&apos;* &lt;=&gt; *&apos;</span>, [
      style({ <span class="hljs-attr">position</span>: <span class="hljs-string">&apos;relative&apos;</span> }),
      query(<span class="hljs-string">&apos;:enter, :leave&apos;</span>, [
        style({
          <span class="hljs-attr">position</span>: <span class="hljs-string">&apos;absolute&apos;</span>,
          <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">width</span>: <span class="hljs-string">&apos;100%&apos;</span>
        })
      ]),
      query(<span class="hljs-string">&apos;:enter&apos;</span>, [
        style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;-100%&apos;</span> })
      ]),
      query(<span class="hljs-string">&apos;:leave&apos;</span>, animateChild()),
      group([
        query(<span class="hljs-string">&apos;:leave&apos;</span>, [
          animate(<span class="hljs-string">&apos;200ms ease-out&apos;</span>, style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;100%&apos;</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span> }))
        ]),
        query(<span class="hljs-string">&apos;:enter&apos;</span>, [
          animate(<span class="hljs-string">&apos;300ms ease-out&apos;</span>, style({ <span class="hljs-attr">left</span>: <span class="hljs-string">&apos;0%&apos;</span> }))
        ]),
        query(<span class="hljs-string">&apos;@*&apos;</span>, animateChild())
      ]),
    ])
  ]);
</code></pre>
<p>然后需要在模板文件里绑定能够获取路由<code>Route</code>中<code>data</code>属性的方法<code>getRouteAnimationData</code>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [@<span class="hljs-attr">routeAnimations</span>]=<span class="hljs-string">&quot;getRouteAnimationData()&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>ts文件里定义此方法：(此方法中的api需要引入<code>ChildrenOutletContexts</code>模块，并注入)</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { ChildrenOutletContexts } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/router&apos;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{
  <span class="hljs-title">constructor</span> (<span class="hljs-params"><span class="hljs-keyword">private</span> contexts: ChildrenOutletContexts</span>){}
  <span class="hljs-function"><span class="hljs-title">getRouteAnimationData</span>(<span class="hljs-params"></span>)</span> {
     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.contexts.getContext(<span class="hljs-string">&apos;primary&apos;</span>)?.route?.snapshot?.data?.[<span class="hljs-string">&apos;animation&apos;</span>];
  }
}
</code></pre>
<p>2022.7.7</p>
<hr>
<ol>
<li>看了angular的国际化、动画、依赖注入、变更检测这些东西</li>
<li>给《英雄之旅》的小项目完善了一下</li>
<li>尝试安装zorro-antd，遇到了版本问题，问了问荆工之后，顺利装上</li>
</ol>
<hr>
<ol>
<li>今天体验一下zorro-antd</li>
<li>总结、复盘一下最近学的东西</li>
<li>了解一下13版本与14版本之间的变动</li>
</ol>
<hr>
<h3 id="惰性路由加载">惰性路由加载</h3>
<p>和平常的<code>Component</code>组件不同，需要生成导出为<code>Module</code>的组件；可能不知所措，但其实CLI可以帮我们一键生成</p>
<ul>
<li>普通的创建组件 </li>
</ul>
<p>​        <code>ng generate &lt;component-name&gt;</code></p>
<ul>
<li>创建具有路由特性或可以懒加载的组件 </li>
</ul>
<p>​        <code>ng generate module &lt;component-name&gt; --route &lt;component-name&gt; --module app.module</code></p>
<p>​        生成的文件目录，可以看到多出了<code>orders-routing.module.ts</code>和<code>orders.module.ts</code>文件，前者是子路由配置，后者是导出为模块。</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/b32bf76ffb27ad609c1acd633fe22987.png" alt="b32bf76ffb27ad609c1acd633fe22987.png"></p>
<p>在CLI指令中的配置项</p>
<h4 id="module">module</h4>
<pre><code>ng generate module [name]
ng generate m [name]
</code></pre><p>在给定或默认项目中创建一个新的通用 NgModule 定义。</p>
<h5 id="可配置项">可配置项</h5>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>--flat</code></td>
<td style="text-align:left">在当前项目根目录的顶层创建新文件。</td>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>--module</code></strong></td>
<td style="text-align:left">指定其声明模块。别名: -m</td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>--project</code></td>
<td style="text-align:left">项目的名称。</td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>--route</code></strong></td>
<td style="text-align:left">惰性加载模块的路由路径。提供后，将在新模块中创建一个组件，并将其路由添加到由 <code>--module</code> 选项指定的模块中声明的 <code>Routes</code> 数组中。</td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>--routing</code></td>
<td style="text-align:left">创建一个路由模块。</td>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>--routing-scope</code></td>
<td style="text-align:left">新路由模块的范围。</td>
<td style="text-align:left">`Child</td>
<td style="text-align:left">Root`</td>
<td><code>Child</code></td>
</tr>
</tbody>
</table>
<p>结合下来，我们再解析一下命令的含义：</p>
<ol>
<li>创建一个模块；</li>
<li>并指定其特性是惰性加载的，之后指令本身会自动创建一个组件，并把组件添加到指定模块中的路由数组里；</li>
<li>继续将此模块声明在指定的模块路由中（这里我们指定<code>app.module</code>）</li>
</ol>
<p>因为这个新模块想要惰性加载，所以该命令不会在应用的根模块 <code>app.module.ts</code> 中添加对新特性模块的引用。相反，它将声明的路由 <code>orders</code> 添加到以 <code>--module</code> 选项指定的模块(<code>app.module</code>)中声明的 <code>routes</code> 数组中。</p>
<h2 id="总结">总结</h2>
<h3 id="一些疑问">一些疑问</h3>
<h4 id="href和routerlink的区别"><code>href</code>和<code>routerLink</code>的区别</h4>
<h5 id="href"><code>href</code></h5>
<p>作为<code>a</code>标签的属性，只接受静态的值，不接受<code>angular</code>的管制</p>
<ul>
<li>绝对 URL - 指向另一个站点（比如 href=&quot;<a href="http://www.example.com/index.htm&quot;）" target="_blank">http://www.example.com/index.htm&quot;）</a></li>
<li>相对 URL - 指向站点内的某个文件（href=&quot;index.htm&quot;）</li>
<li>锚 URL - 指向页面中的锚（href=&quot;#top&quot;）</li>
</ul>
<h5 id="routerlink"><code>routerLink</code></h5>
<p>作为与<code>angular-router</code>配套的指令，可以接收静态、动态值，他除了相对路径、绝对路径、还接受一系列动态值生成的路径；该<strong>属性的输入将被视为当前 URL 的增量</strong></p>
<blockquote>
<p> 比如：假设当前 URL 是 <code>/user/(box//aux:team)</code>。则链接 <code>&lt;a [routerLink]=&quot;[&apos;/user/jim&apos;]&quot;&gt;Jim&lt;/a&gt;</code> 会创建 URL <code>/user/(jim//aux:team)</code> 。</p>
</blockquote>
<p>动态值的使用：</p>
<blockquote>
<p>比如， 输入<code>[&apos;/team&apos;, teamId, &apos;user&apos;, userName, {details: true}]</code> 生成到 <code>/team/11/user/bob;details=true</code> 。</p>
</blockquote>
<h5 id="两者的区别">两者的区别</h5>
<ul>
<li><strong><code>href</code>会销毁跳转之前的<code>DOM</code>元素，<code>routerLink</code>则会保留</strong></li>
<li><code>routerLink</code>可以向<code>Router</code>传递值和配置项</li>
<li><code>routerLink</code>会生成<code>UrlTree</code>代表路由器的状态</li>
</ul>
<h5 id="相对url的使用">相对URL的使用</h5>
<p>第一段名称可以用 <code>/</code>、<code>./</code> 或 <code>../</code> 开头。</p>
<ul>
<li>如果第一个片段用 <code>/</code> 开头，则路由器会从应用的根路由开始查找。</li>
<li>如果第一个片段用 <code>./</code> 开头或者没有用斜杠开头，路由器就会从当前激活路由开始查找。</li>
<li>如果第一段以 <code>../</code> 开头，则路由器将去往路由树中的上一层。</li>
</ul>
<h3 id="版本变化">版本变化</h3>
<h4 id="angular-13--angular-14">Angular 13 =&gt; Angular 14</h4>
<ul>
<li>确保您使用的是<a href="http://www.hostingadvice.com/how-to/update-node-js-latest-version/" target="_blank">Node 14.15.0 或更高版本</a></li>
<li>表单模型现在需要一个泛型类型参数。对于逐步迁移，您可以选择退出使用表单模型类的无类型版本。</li>
<li>删除<code>aotSummaries</code>，<code>TestBed</code>因为 Angular 在 Ivy 中不再需要它们。</li>
<li>从 JSONP 请求中删除标头。JSONP 不支持标头，如果指定，HTTP 模块现在将抛出错误而不是忽略它们。</li>
<li>解析器现在将通过 observable 获取第一个发出的值，然后继续导航以更好地与其他守卫对齐，而不是采用最后一个发出的值。</li>
<li>更新<code>initialNavigation: &apos;enabled&apos;</code>到<code>initialNavigation: &apos;enabledBlocking&apos;</code>.</li>
<li>如果您使用 定义路由<code>pathMatch</code>，则可能必须将其强制转换为<code>Route</code>或<code>Routes</code>显式转换。<code>Route.pathMatch</code>不再与<code>string</code>类型兼容。</li>
<li>现在返回的 promise<code>LoadChildrenCallback</code>具有更严格的类型参数<code>Type&lt;any&gt;|NgModuleFactory&lt;any&gt;</code>，而不是<code>any</code>.</li>
<li>路由器不再在<code>setTimeout</code>. 确保您的测试不依赖此行为。</li>
<li>实现<code>LocationStrategy</code>接口现在需要定义<code>getState()</code>.</li>
<li>作为查询的一部分发送<code>+</code>不再需要解决方法，因为<code>+</code>不再发送空格。</li>
<li>现在实施<code>AnimationDriver</code>需要<code>getParentElement</code>方法。</li>
<li>延迟加载模块的无效路由配置现在将引发错误而不是被忽略。</li>
<li>删除<code>resolver</code>from<code>RouterOutletContract.activateWith</code>函数和<code>resolver</code>from<code>OutletContext</code>类，因为不再需要工厂解析器。</li>
<li><code>Router.initialUrl</code>仅接受以通过分配值<code>UrlTree</code>来防止滥用 API 。<code>string</code></li>
</ul>
<p>2022.7.9</p>
<hr>
<ol>
<li>解决一下问题，尝试了antd的抽屉组件</li>
<li>总结、复盘一下最近学的东西</li>
<li>了解一下13版本与14版本之间的变动</li>
</ol>
<hr>
<ol>
<li>Dart语言</li>
<li>熟悉项目</li>
<li>...</li>
</ol>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="flutter的学习笔记.html" class="navigation navigation-next navigation-unique" aria-label="Next page: flutter的学习笔记">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Angular学习笔记","level":"1.2.1","depth":2,"next":{"title":"flutter的学习笔记","level":"1.2.2","depth":2,"path":"Angular/flutter的学习笔记.md","ref":"Angular/flutter的学习笔记.md","articles":[]},"previous":{"title":"Angular","level":"1.2","depth":1,"ref":"","articles":[{"title":"Angular学习笔记","level":"1.2.1","depth":2,"path":"Angular/Angular学习笔记.md","ref":"Angular/Angular学习笔记.md","articles":[]},{"title":"flutter的学习笔记","level":"1.2.2","depth":2,"path":"Angular/flutter的学习笔记.md","ref":"Angular/flutter的学习笔记.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":[],"root":"bookEdit","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"producer":"jasonk0","structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"Angular/Angular学习笔记.md","mtime":"2022-07-21T01:20:03.183Z","type":"markdown"},"gitbook":{"version":"3.7.5","time":"2022-07-21T01:30:22.323Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

