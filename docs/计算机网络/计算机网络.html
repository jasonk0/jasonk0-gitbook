
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>计算机网络 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.7.5">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-cmb-pageview/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="工具链和其他.html" />
    
    
    <link rel="prev" href="../" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="计算机网络.html">
            
                <a href="计算机网络.html">
            
                    
                    计算机网络
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="工具链和其他.html">
            
                <a href="工具链和其他.html">
            
                    
                    工具链和其他
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="浏览器状态同步和路由.html">
            
                <a href="浏览器状态同步和路由.html">
            
                    
                    浏览器状态同步和路由
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="网络安全攻防.html">
            
                <a href="网络安全攻防.html">
            
                    
                    网络安全攻防
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../杂篇/">
            
                <a href="../杂篇/">
            
                    
                    杂篇
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../杂篇/踩坑日记.html">
            
                <a href="../杂篇/踩坑日记.html">
            
                    
                    踩坑日记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../杂篇/预习资料.html">
            
                <a href="../杂篇/预习资料.html">
            
                    
                    预习资料
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../杂篇/直播.html">
            
                <a href="../杂篇/直播.html">
            
                    
                    直播
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../Angular/">
            
                <a href="../Angular/">
            
                    
                    Angular
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../Angular/Angular学习笔记.html">
            
                <a href="../Angular/Angular学习笔记.html">
            
                    
                    Angular学习笔记
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../Angular/flutter的学习笔记.html">
            
                <a href="../Angular/flutter的学习笔记.html">
            
                    
                    flutter的学习笔记
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../js进阶/">
            
                <a href="../js进阶/">
            
                    
                    js进阶
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../js进阶/高阶函数.html">
            
                <a href="../js进阶/高阶函数.html">
            
                    
                    高阶函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../js进阶/轮播图设计.html">
            
                <a href="../js进阶/轮播图设计.html">
            
                    
                    轮播图设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../js进阶/设计模式.html">
            
                <a href="../js进阶/设计模式.html">
            
                    
                    设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../js进阶/异步编程.html">
            
                <a href="../js进阶/异步编程.html">
            
                    
                    异步编程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../node/">
            
                <a href="../node/">
            
                    
                    node
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../node/node_01.html">
            
                <a href="../node/node_01.html">
            
                    
                    node_01
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../node/node_02.html">
            
                <a href="../node/node_02.html">
            
                    
                    node_02
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../node/node_03.html">
            
                <a href="../node/node_03.html">
            
                    
                    node_03
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../node/node的web框架koa.html">
            
                <a href="../node/node的web框架koa.html">
            
                    
                    node的web框架koa
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../node/node基础.html">
            
                <a href="../node/node基础.html">
            
                    
                    node基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../node/node与mongDB.html">
            
                <a href="../node/node与mongDB.html">
            
                    
                    node与mongDB
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../react/">
            
                <a href="../react/">
            
                    
                    react
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../react/React前厅（基础）.html">
            
                <a href="../react/React前厅（基础）.html">
            
                    
                    React前厅（基础）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../vue/">
            
                <a href="../vue/">
            
                    
                    vue
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../vue/TypeScript.html">
            
                <a href="../vue/TypeScript.html">
            
                    
                    TypeScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../vue/vue3.html">
            
                <a href="../vue/vue3.html">
            
                    
                    vue3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../vue/vue基础.html">
            
                <a href="../vue/vue基础.html">
            
                    
                    vue基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../vue/vue生态.html">
            
                <a href="../vue/vue生态.html">
            
                    
                    vue生态
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../z-Clean-Architecture/">
            
                <a href="../z-Clean-Architecture/">
            
                    
                    Clean-Architecture
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../z-Clean-Architecture/01-第一部分-概述/">
            
                <a href="../z-Clean-Architecture/01-第一部分-概述/">
            
                    
                    第一部分-概述
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1.1" data-path="../z-Clean-Architecture/01-第一部分-概述/1-设计与架构究竟是什么.html">
            
                <a href="../z-Clean-Architecture/01-第一部分-概述/1-设计与架构究竟是什么.html">
            
                    
                    设计与架构究竟是什么
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.2" data-path="../z-Clean-Architecture/01-第一部分-概述/2-两个价值维度.html">
            
                <a href="../z-Clean-Architecture/01-第一部分-概述/2-两个价值维度.html">
            
                    
                    两个价值维度
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/">
            
                <a href="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/">
            
                    
                    第二部分-从基础构件开始：编程范式
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.2.1" data-path="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/3-编程范式总览.html">
            
                <a href="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/3-编程范式总览.html">
            
                    
                    编程范式总览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.2" data-path="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/4-结构化编程.html">
            
                <a href="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/4-结构化编程.html">
            
                    
                    结构化编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.3" data-path="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/5-面向对象编程.html">
            
                <a href="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/5-面向对象编程.html">
            
                    
                    面向对象编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.4" data-path="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/6-函数式编程.html">
            
                <a href="../z-Clean-Architecture/02-第二部分-从基础构件开始：编程范式/6-函数式编程.html">
            
                    
                    函数式编程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../z-Clean-Architecture/03-第三部分-设计原则/">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/">
            
                    
                    第三部分-设计原则
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.3.1" data-path="../z-Clean-Architecture/03-第三部分-设计原则/7-SRP：单一职责原则.html">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/7-SRP：单一职责原则.html">
            
                    
                    SRP：单一职责原则
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.2" data-path="../z-Clean-Architecture/03-第三部分-设计原则/8-OCP：开闭原则.html">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/8-OCP：开闭原则.html">
            
                    
                    OCP：开闭原则
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.3" data-path="../z-Clean-Architecture/03-第三部分-设计原则/9-LSP：里氏替换原则.html">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/9-LSP：里氏替换原则.html">
            
                    
                    LSP：里氏替换原则
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.4" data-path="../z-Clean-Architecture/03-第三部分-设计原则/10-ISP：接口隔离原则.html">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/10-ISP：接口隔离原则.html">
            
                    
                    ISP：接口隔离原则
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.5" data-path="../z-Clean-Architecture/03-第三部分-设计原则/11-DIP：依赖反转原则.html">
            
                <a href="../z-Clean-Architecture/03-第三部分-设计原则/11-DIP：依赖反转原则.html">
            
                    
                    DIP：依赖反转原则
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../z-Clean-Architecture/04-第四部分-组件构建原则/">
            
                <a href="../z-Clean-Architecture/04-第四部分-组件构建原则/">
            
                    
                    第四部分-组件构建原则
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.4.1" data-path="../z-Clean-Architecture/04-第四部分-组件构建原则/12-组件.html">
            
                <a href="../z-Clean-Architecture/04-第四部分-组件构建原则/12-组件.html">
            
                    
                    组件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4.2" data-path="../z-Clean-Architecture/04-第四部分-组件构建原则/13-组件聚合.html">
            
                <a href="../z-Clean-Architecture/04-第四部分-组件构建原则/13-组件聚合.html">
            
                    
                    组件聚合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4.3" data-path="../z-Clean-Architecture/04-第四部分-组件构建原则/14-组件耦合.html">
            
                <a href="../z-Clean-Architecture/04-第四部分-组件构建原则/14-组件耦合.html">
            
                    
                    组件耦合
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../z-Clean-Architecture/05-第五部分-软件架构/">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/">
            
                    
                    第五部分-软件架构
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.5.1" data-path="../z-Clean-Architecture/05-第五部分-软件架构/15-什么是软件架构.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/15-什么是软件架构.html">
            
                    
                    什么是软件架构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.2" data-path="../z-Clean-Architecture/05-第五部分-软件架构/16-独立性.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/16-独立性.html">
            
                    
                    独立性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.3" data-path="../z-Clean-Architecture/05-第五部分-软件架构/17-划分边界.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/17-划分边界.html">
            
                    
                    划分边界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.4" data-path="../z-Clean-Architecture/05-第五部分-软件架构/18-边界剖析.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/18-边界剖析.html">
            
                    
                    边界剖析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.5" data-path="../z-Clean-Architecture/05-第五部分-软件架构/19-策略与层次.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/19-策略与层次.html">
            
                    
                    策略与层次
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.6" data-path="../z-Clean-Architecture/05-第五部分-软件架构/20-业务逻辑.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/20-业务逻辑.html">
            
                    
                    业务逻辑
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.7" data-path="../z-Clean-Architecture/05-第五部分-软件架构/21-尖叫的软件架构.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/21-尖叫的软件架构.html">
            
                    
                    尖叫的软件架构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.8" data-path="../z-Clean-Architecture/05-第五部分-软件架构/22-整洁架构.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/22-整洁架构.html">
            
                    
                    整洁架构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.9" data-path="../z-Clean-Architecture/05-第五部分-软件架构/23-展示器和谦卑对象.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/23-展示器和谦卑对象.html">
            
                    
                    展示器和谦卑对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.10" data-path="../z-Clean-Architecture/05-第五部分-软件架构/24-不完全边界.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/24-不完全边界.html">
            
                    
                    不完全边界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.11" data-path="../z-Clean-Architecture/05-第五部分-软件架构/25-层次与边界.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/25-层次与边界.html">
            
                    
                    层次与边界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.12" data-path="../z-Clean-Architecture/05-第五部分-软件架构/26-Main组件.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/26-Main组件.html">
            
                    
                    Main组件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.13" data-path="../z-Clean-Architecture/05-第五部分-软件架构/27-服务：宏观和微观.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/27-服务：宏观和微观.html">
            
                    
                    服务：宏观和微观
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.14" data-path="../z-Clean-Architecture/05-第五部分-软件架构/28-测试边界.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/28-测试边界.html">
            
                    
                    测试边界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5.15" data-path="../z-Clean-Architecture/05-第五部分-软件架构/29-整洁的嵌入式架构.html">
            
                <a href="../z-Clean-Architecture/05-第五部分-软件架构/29-整洁的嵌入式架构.html">
            
                    
                    整洁的嵌入式架构
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../z-Clean-Architecture/06-第六部分-实现细节/">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/">
            
                    
                    第六部分-实现细节
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.6.1" data-path="../z-Clean-Architecture/06-第六部分-实现细节/30-数据库只是实现细节.html">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/30-数据库只是实现细节.html">
            
                    
                    数据库只是实现细节
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6.2" data-path="../z-Clean-Architecture/06-第六部分-实现细节/31-Web是实现细节.html">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/31-Web是实现细节.html">
            
                    
                    Web是实现细节
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6.3" data-path="../z-Clean-Architecture/06-第六部分-实现细节/32-应用程序框架是实现细节.html">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/32-应用程序框架是实现细节.html">
            
                    
                    应用程序框架是实现细节
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6.4" data-path="../z-Clean-Architecture/06-第六部分-实现细节/33-案例分析：视频销售网站.html">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/33-案例分析：视频销售网站.html">
            
                    
                    案例分析：视频销售网站
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6.5" data-path="../z-Clean-Architecture/06-第六部分-实现细节/34-拾遗.html">
            
                <a href="../z-Clean-Architecture/06-第六部分-实现细节/34-拾遗.html">
            
                    
                    拾遗
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../z-Clean-Architecture/afterword.html">
            
                <a href="../z-Clean-Architecture/afterword.html">
            
                    
                    afterword
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >计算机网络</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><ul><li><span class="title-icon "></span><a href="#计算机网络"><b>1.1. </b>计算机网络</a></li><ul><li><span class="title-icon "></span><a href="#计算机网络历史"><b>1.1.1. </b>计算机网络历史</a></li><li><span class="title-icon "></span><a href="#osi七层模型"><b>1.1.2. </b>OSI七层模型</a></li><li><span class="title-icon "></span><a href="#网络协议"><b>1.1.3. </b>网络协议</a></li><li><span class="title-icon "></span><a href="#网络请求实战"><b>1.1.4. </b>网络请求实战</a></li></ul></ul></ul></div><a href="#" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p>[TOC]</p>
<h2 id="计算机网络"><a name="计算机网络" class="anchor-navigation-ex-anchor" href="#计算机网络"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. 计算机网络</h2>
<h3 id="计算机网络历史"><a name="计算机网络历史" class="anchor-navigation-ex-anchor" href="#计算机网络历史"><i class="fa fa-link" aria-hidden="true"></i></a>1.1.1. 计算机网络历史</h3>
<p>ARPAnet</p>
<p>封包(pack-switching)</p>
<p><img src="http://g.recordit.co/BeC31jlvCe.gif" alt="fengbao"></p>
<ul>
<li>1969年</li>
</ul>
<p>第一个RFC（request-for-comment）</p>
<p>第一个接口信息处理单元（Interface-Message-Processor）（路由器的前身）</p>
<p>互联网Internet</p>
<ul>
<li>1971年</li>
</ul>
<p>第一个email（ARPAnet）也是世界上第一个网络</p>
<p>ALOHAnet 第一个wi-fi（Wireless Fidelity）</p>
<ul>
<li>1973年 </li>
</ul>
<p>Ethernet （局域网的前身）</p>
<p>SATNET （卫星网络）</p>
<p>IP电话/互联网电话（VOIP）（第一个给用户使用的电话在1995年）</p>
<ul>
<li>1974年</li>
</ul>
<p>路由器（施乐Xerox）</p>
<ul>
<li>1976年 </li>
</ul>
<p>第一个IP路由器，但是被称作网关（Gateway）</p>
<ul>
<li>1978年</li>
</ul>
<p>Bob Kahn发明了TCP/IP协议</p>
<ul>
<li>1981年</li>
</ul>
<p>Internet protocol Version 4，RCF 791</p>
<p>BITnet</p>
<p>CSnet</p>
<ul>
<li>1983年</li>
</ul>
<p>ARPAnet迁移到TCP/IP协议</p>
<p>DNS（Domain Name System）</p>
<p>1986年</p>
<ul>
<li>1988年 </li>
</ul>
<p>WaveLan（WI-FI）</p>
<p>Packet filter wall（第一个防火墙Paper）</p>
<p>APAPnet</p>
<ul>
<li><p>1990年 第一个交换机（Kalpana）</p>
</li>
<li><p>1996年 IPv6</p>
</li>
<li><p>1997年 802.11 wifi标准（2mbps）</p>
</li>
<li>1999年</li>
</ul>
<p>802.11a（5GHz 25mbps）、802.11b标准（11mbps）</p>
<p>WEP加密协议（RC4对称加密+CRC-32）</p>
<ul>
<li>2000s</li>
</ul>
<p>802.11g标准（54mbps）</p>
<p>WPA加密协议</p>
<p>WPA2加密协议</p>
<p>4G标准（100Mbps）</p>
<p>802.11n标准（600mbps）</p>
<ul>
<li>现在</li>
</ul>
<p>移动互联网、5G、边缘计算、云、物联网、VR</p>
<h3 id="osi七层模型"><a name="osi七层模型" class="anchor-navigation-ex-anchor" href="#osi七层模型"><i class="fa fa-link" aria-hidden="true"></i></a>1.1.2. OSI七层模型</h3>
<h4 id="osi模型简介"><a name="osi模型简介" class="anchor-navigation-ex-anchor" href="#osi模型简介"><i class="fa fa-link" aria-hidden="true"></i></a>OSI模型简介</h4>
<p>（ISO/IEC 7498-1）</p>
<ul>
<li><p>开放式系统互联模型</p>
</li>
<li><p>世界范围内的网络标准概念模型</p>
</li>
<li><p>OSI的努力让互联网协议走向标准化</p>
</li>
</ul>
<p>国际标准化组织（ISO）</p>
<p>始于欧洲，发扬于美国，中国获利</p>
<h5 id="应用层（application-layeer）"><a name="应用层（application-layeer）" class="anchor-navigation-ex-anchor" href="#应用层（application-layeer）"><i class="fa fa-link" aria-hidden="true"></i></a>应用层（Application Layeer）</h5>
<p>提供高级API</p>
<blockquote>
<p>定义了网络主机提供的方法和接口（业务协议），往往直接对应用户行为，例如：HTTP、FTP、SMTP等</p>
</blockquote>
<h5 id="展示层（presentation-layer）"><a name="展示层（presentation-layer）" class="anchor-navigation-ex-anchor" href="#展示层（presentation-layer）"><i class="fa fa-link" aria-hidden="true"></i></a>展示层（Presentation Layer）</h5>
<blockquote>
<p>也被称作语法层，将应用层中的数据转化为传输格式，保留语义（序列化、加密解密、字符串编码解码）；确保数据发送出去后可以被接收者理解。</p>
</blockquote>
<h5 id="会话层（session-layer）"><a name="会话层（session-layer）" class="anchor-navigation-ex-anchor" href="#会话层（session-layer）"><i class="fa fa-link" aria-hidden="true"></i></a>会话层（Session Layer）</h5>
<blockquote>
<p>提供管理会话的方法（Open/Close/ReOpen/检查状态等），提供对底层连续断断续续的隐藏，甚至对多种底层流的隐藏，保证上层看不到细节</p>
</blockquote>
<h5 id="传输层（transport-layer）"><a name="传输层（transport-layer）" class="anchor-navigation-ex-anchor" href="#传输层（transport-layer）"><i class="fa fa-link" aria-hidden="true"></i></a>传输层（Transport Layer）</h5>
<p>提供主机到主机（host-to-host）的数据通信能力</p>
<blockquote>
<p>建立简介保证数据封包发送、接收到的顺序一致；提供可靠性（发送者知道数据有没有被完整送达）；提供流控制（同步发送者和接受者的速率）；提供多路复用（「多工」，Multiplexing，多种信号复用一个信道）</p>
</blockquote>
<p><img src="https://www.hualigs.cn/image/61e7ba2f14104.jpg" alt="多路复用"></p>
<h5 id="网络层（network-layer）"><a name="网络层（network-layer）" class="anchor-navigation-ex-anchor" href="#网络层（network-layer）"><i class="fa fa-link" aria-hidden="true"></i></a>网络层（Network Layer）</h5>
<p>提供数据在逻辑单元（IP地址）之间的传递能力</p>
<blockquote>
<p>「路由」：决定数据的下一站在哪里；「寻址」：为数据封包增加头信息（地址等）</p>
</blockquote>
<h5 id="数据链路层（data-link-layer）"><a name="数据链路层（data-link-layer）" class="anchor-navigation-ex-anchor" href="#数据链路层（data-link-layer）"><i class="fa fa-link" aria-hidden="true"></i></a>数据链路层（Data Link Layer）</h5>
<p>提供数据在设别和设备间的传输能力</p>
<blockquote>
<p>「流控制」：发送者接受者之间同步数据首发速度和数据量，「错误控制」：检测数据有没有出错，并重发出错的信息</p>
</blockquote>
<h5 id="物理层（physical-layer"><a name="物理层（physical-layer" class="anchor-navigation-ex-anchor" href="#物理层（physical-layer"><i class="fa fa-link" aria-hidden="true"></i></a>物理层（Physical Layer)</h5>
<p>定义底层一个个位（bit）的数据如何变成物理信号</p>
<blockquote>
<p>数据链路层发生的数据传递行为转化为物理设备识别的信号（电流）；封装了大量底层物理设备的能力</p>
</blockquote>
<h4 id="实际应用"><a name="实际应用" class="anchor-navigation-ex-anchor" href="#实际应用"><i class="fa fa-link" aria-hidden="true"></i></a>实际应用</h4>
<ul>
<li>Alice想Bob发微信</li>
</ul>
<p>Alice提交的输入被微信存储成某种内部协议格式——「应用层」</p>
<p>数据被转化为传输用的格式（如加密、压缩等）——「表示层」</p>
<p>微信客户端建立起与服务器的连接（也可能已经建立好了）「会话层」</p>
<p>微信客户端向服务器传输数据——「传输层」</p>
<p>一个个数据封包从主机传输到服务器——「网络层」</p>
<p>数据帧在一个个设备之间传输——「数据链路层」</p>
<p>数据最终以光电信号的形式在物理设备间传输——「物理层」</p>
<h4 id="深入思考osi"><a name="深入思考osi" class="anchor-navigation-ex-anchor" href="#深入思考osi"><i class="fa fa-link" aria-hidden="true"></i></a>深入思考OSI</h4>
<p><img src="https://www.hualigs.cn/image/61e7bd77c14d5.jpg" alt="OSI七层和对应的事情"></p>
<p>分层架构</p>
<p>替换其中一层不用重构整个应用（比如换了一家快递，我依然可以把快递送到目标地址）</p>
<ul>
<li>必要性/独立性/可替换</li>
<li>层的颗粒度</li>
<li>数据可追踪性</li>
</ul>
<hr>
<h3 id="网络协议"><a name="网络协议" class="anchor-navigation-ex-anchor" href="#网络协议"><i class="fa fa-link" aria-hidden="true"></i></a>1.1.3. 网络协议</h3>
<h4 id="tcpip协议和互联网"><a name="tcpip协议和互联网" class="anchor-navigation-ex-anchor" href="#tcpip协议和互联网"><i class="fa fa-link" aria-hidden="true"></i></a>TCP/IP协议和互联网</h4>
<h5 id="tcpip协议群（internet-protocol-suite）"><a name="tcpip协议群（internet-protocol-suite）" class="anchor-navigation-ex-anchor" href="#tcpip协议群（internet-protocol-suite）"><i class="fa fa-link" aria-hidden="true"></i></a>TCP/IP协议群（Internet Protocol Suite）</h5>
<p>类似OSI模型，一种网络协议的概念模型</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/ba139c3e8d94c4dcb794a77053b67bec.png" alt="TCP/IP"></p>
<p>传输层（Transport Layer）</p>
<p>提供主机到主机的通信能力，通过TCP/UDP协议</p>
<p>还有主机端口（浏览器默认80端口）</p>
<p>网络层（Internet Layer）</p>
<p>提供地址到地址的通信能力，通过IP协议</p>
<p>链路层（Link Layer）</p>
<p>提供设备到设备的通信能力，Mac地址到Mac地址</p>
<p><strong>什么是设备、地址、应用？</strong></p>
<p>分别对应链路层、网络层、传输层</p>
<p>设备：MAC；地址：IP；应用：端口</p>
<h5 id="tcpip封包"><a name="tcpip封包" class="anchor-navigation-ex-anchor" href="#tcpip封包"><i class="fa fa-link" aria-hidden="true"></i></a>TCP/IP封包</h5>
<p>各层之间的数据转换</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/TCP/IP数据转换和封包.png" alt="数据转换"></p>
<p>TCP/IP的封包</p>
<p>（网络层）通过IP协议在进行一次数据的封装加上IP的header，称为<strong>IP协议的封包</strong></p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/TCP/IP封包.png" alt="封包"></p>
<p>完整的TCP协议头</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/TCP.png" alt="TCP的协议头"></p>
<p>tcp的header相当于一个说明书，后边跟着一段段的数据，header来指明数据的类型，编码的格式，原地址，目标地址等信息</p>
<p>这样就形成了一个<strong>TCP协议的封包</strong>（传输层）</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/TCP封包.png" alt="TCP封包"></p>
<ul>
<li><p>每个封包称作一个TCP信息段（TCP Segment)</p>
</li>
<li><p>Header用户描述传输行为</p>
</li>
<li>Header后边跟着若干个byte数据，每个byte拥有自己的序列号</li>
</ul>
<h5 id="三次握手"><a name="三次握手" class="anchor-navigation-ex-anchor" href="#三次握手"><i class="fa fa-link" aria-hidden="true"></i></a>三次握手</h5>
<p>syn 请求同步</p>
<p>syn-ack 请求并确认</p>
<p>ack 确认</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/三次握手.png" alt="三次握手"></p>
<h5 id="数据顺序问题"><a name="数据顺序问题" class="anchor-navigation-ex-anchor" href="#数据顺序问题"><i class="fa fa-link" aria-hidden="true"></i></a>数据顺序问题</h5>
<p>TCP/IP的处理方法：</p>
<p>消息的绝对顺序用（SEQ，ACK）这一对元组描述，这个元组就保存在TCP的header中</p>
<blockquote>
<p>SEQ(Sequence)：这个消息发送前一共发送了多少字节</p>
<p>ACK(Acknowledge)：这个消息发送前一共收到了多少个字节</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/改良的三次握手.png" alt="改良的三次握手"></p>
<h5 id="四次挥手"><a name="四次挥手" class="anchor-navigation-ex-anchor" href="#四次挥手"><i class="fa fa-link" aria-hidden="true"></i></a>四次挥手</h5>
<p>在断开连接的时候，每一端都要发送Finish和Ackonwledge，在接收完断开之前的信息之后再发送Ackownledge</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/四次挥手.png" alt="四次挥手"></p>
<h5 id="总结"><a name="总结" class="anchor-navigation-ex-anchor" href="#总结"><i class="fa fa-link" aria-hidden="true"></i></a>总结</h5>
<p>「最简化原则」：没有足够的事情要做，就不必分层</p>
<p>为什么需要三次握手？四次挥手？</p>
<p>网络中的顺序问题，是通过(SEQ,ACK)这组绝对数据来解决的</p>
<hr>
<h4 id="dns（重点）"><a name="dns（重点）" class="anchor-navigation-ex-anchor" href="#dns（重点）"><i class="fa fa-link" aria-hidden="true"></i></a>DNS（重点）</h4>
<h5 id="dns基础知识"><a name="dns基础知识" class="anchor-navigation-ex-anchor" href="#dns基础知识"><i class="fa fa-link" aria-hidden="true"></i></a>DNS基础知识</h5>
<p>URL：也被称作「网址」，用于定位互联网上的资源。由方案（协议）、域名（主机/IP地址）、端口（应用）、路径、查询、片段（给客户端使用）组成</p>
<p><img src="https://www.hualigs.cn/image/61e7efd5a4c11.jpg" alt="URL"></p>
<p>DNS（Domain Name System）：域名系统，将域名解析为IP地址。</p>
<p><img src="https://www.hualigs.cn/image/61e7f12cbf498.jpg" alt="DNS查询过程"></p>
<p>「AA」 ：Authoritative Answer 权威回答</p>
<ul>
<li>A记录</li>
</ul>
<p>描述IPv4地址。其中IN（Internet）代表大部分网络</p>
<blockquote>
<p>www.example.com. IN A 139.22.33.2</p>
</blockquote>
<ul>
<li>AAAA记录</li>
</ul>
<p>IPv6的记录</p>
<ul>
<li>CNAME记录（Canonical Name Record）</li>
</ul>
<p>前者作为后者的别名记录下来</p>
<blockquote>
<p>www.foo.com. IN CNAME example.com</p>
</blockquote>
<ul>
<li>MX记录（Mail exchaner record）</li>
</ul>
<p>定为邮件服务器</p>
<blockquote>
<p>123@qq.com. IN MX qq.com</p>
</blockquote>
<ul>
<li>NS记录（Name Server Record）</li>
</ul>
<p>定义提供dns信息的服务器（A的子服务）</p>
<ul>
<li>SOA记录（Start of Authority Record）</li>
</ul>
<p>定义在多个NS服务器中那个是主服务器</p>
<ul>
<li>TXT记录</li>
</ul>
<p>微信提供文本信息，将其加入到我的域名之下，在请求微信的域名的时候带上文本可以证明我的域名身份。</p>
<h5 id="dns工具实战"><a name="dns工具实战" class="anchor-navigation-ex-anchor" href="#dns工具实战"><i class="fa fa-link" aria-hidden="true"></i></a>DNS工具实战</h5>
<p>本地host修改：Switchhost工具</p>
<h5 id="cdn工具"><a name="cdn工具" class="anchor-navigation-ex-anchor" href="#cdn工具"><i class="fa fa-link" aria-hidden="true"></i></a>CDN工具</h5>
<p>CDN：内容分发网络（Content Delivery Network）</p>
<p><img src="https://www.hualigs.cn/image/61e7f5df5aea0.jpg" alt="CDN"></p>
<p>基于地理位置的分布式代理服务器/数据中心</p>
<ul>
<li>提供高可用</li>
<li>提升性能</li>
<li>提升体验</li>
</ul>
<p>中国的主干网络</p>
<ul>
<li>中国联通</li>
<li>中国电信</li>
<li>中国移动</li>
<li>中国教育和科研计算机网</li>
<li>中国科技网</li>
<li>广电带宽（2018）</li>
<li>……</li>
</ul>
<p>CDN实现原理</p>
<p><img src="https://www.hualigs.cn/image/61e7f7ab55981.jpg" alt="CDN原理"></p>
<ul>
<li><p>适用于静态资源，不经常变动。</p>
</li>
<li><p>修改CDN上的资源非常麻烦。</p>
</li>
</ul>
<p>CDN云测平台</p>
<p><a href="https://17ce.com/" target="_blank">17ce</a></p>
<h4 id="http入门和基础工具"><a name="http入门和基础工具" class="anchor-navigation-ex-anchor" href="#http入门和基础工具"><i class="fa fa-link" aria-hidden="true"></i></a>Http入门和基础工具</h4>
<h5 id="http协议"><a name="http协议" class="anchor-navigation-ex-anchor" href="#http协议"><i class="fa fa-link" aria-hidden="true"></i></a>HTTP协议</h5>
<p>超文本传输协议（Hyper Text Transfer Protocol）</p>
<p>处理客户端和服务端之间的通信，可以使用<strong>文本</strong>传输信息，而不是二进制。</p>
<p>http请求 - http返回</p>
<p>主要用于请求网页/json/提交表单/xml……</p>
<h5 id="纯文本无状态（stateless）"><a name="纯文本无状态（stateless）" class="anchor-navigation-ex-anchor" href="#纯文本无状态（stateless）"><i class="fa fa-link" aria-hidden="true"></i></a>纯文本+无状态（stateless）</h5>
<blockquote>
<p>无状态，相对简单，每一个请求都是独立的，互相不影响</p>
</blockquote>
<p>但是我们需要通过cookie，session等浏览器提供的手段维护状态</p>
<h5 id="历史及设计优化"><a name="历史及设计优化" class="anchor-navigation-ex-anchor" href="#历史及设计优化"><i class="fa fa-link" aria-hidden="true"></i></a>历史及设计优化</h5>
<blockquote>
<p>在网络协议设计中，带宽和延迟是非常重要的因素，和用户体验紧密联系；而延迟可以通过缓存、DNS查询等优化来降低</p>
</blockquote>
<p>1991 HTTP 0.9</p>
<p>1996 HTTP 1.0</p>
<ul>
<li><p>缓存</p>
<p>提供缓存机制如IF-Modified-Since等基础缓存控制策略</p>
</li>
</ul>
<p>1999 HTTP 1.1</p>
<ul>
<li><p>缓存优化</p>
<p>提供E-tag等高级缓存策略</p>
</li>
<li><p>带宽优化</p>
<p>利用长链接让多个请求在一个TCP连接上排队</p>
<p>利用range(范围)头获取文件的某个部分</p>
</li>
</ul>
<p>2015 HTTP 2.0</p>
<ul>
<li><p>带宽优化</p>
<p>利用多路复用技术同时传输多个请求</p>
</li>
</ul>
<h5 id="压缩安全性"><a name="压缩安全性" class="anchor-navigation-ex-anchor" href="#压缩安全性"><i class="fa fa-link" aria-hidden="true"></i></a>压缩/安全性</h5>
<ul>
<li><p>压缩</p>
<p>主流web服务器nginx/express都提供gzip压缩</p>
<p>http2.0采用二进制传输，头部使用HPACK算法压缩</p>
</li>
<li><p>HTTPS</p>
<p>在HHTTP和TCP/IP之间增加TSL/SSL层</p>
<p>数据传输加密（非对称和对称）</p>
</li>
</ul>
<h5 id="实战-实现简单http协议"><a name="实战-实现简单http协议" class="anchor-navigation-ex-anchor" href="#实战-实现简单http协议"><i class="fa fa-link" aria-hidden="true"></i></a>实战-实现简单http协议</h5>
<p>http传输内容分为两部分Header和Body。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;net&apos;</span>)
<span class="hljs-comment">// 基础能力 发送数据 传输层=》网络层 =〉 连接层 =》 物理层，也就是可以操纵TCP协议</span>
<span class="hljs-keyword">const</span> response = 
<span class="hljs-string">`HTTP/1.1 200 OK
Data: Tue, 30 Jun 2000 01:00:00 GMT
Content-Type: text/plain
Connection: Closed

Hello World
`</span>
<span class="hljs-keyword">const</span> server = net.createServer(<span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> {
  socket.end(response)
})

server.listen(<span class="hljs-number">80</span>,()=&gt;{

})
</code></pre>
<h5 id="工具"><a name="工具" class="anchor-navigation-ex-anchor" href="#工具"><i class="fa fa-link" aria-hidden="true"></i></a>工具</h5>
<p>cURL 命令行工具 ，可以请求url</p>
<blockquote>
<p>它支持很多协议</p>
</blockquote>
<p>fetch 在网络还是那个获取数据的标准接口</p>
<blockquote>
<p>提供 请求/返回 标准Promise标准方法</p>
<p>提供自定义Header能力</p>
<p>提供跨域能力</p>
</blockquote>
<p>postman 协作的API开发工具</p>
<p>Whistle 跨平台网络调试工具，抓包</p>
<blockquote>
<p>需要SwitchOmega插件</p>
<p>nodejs开发</p>
<p>支持抓包、重放、替换、修改</p>
</blockquote>
<p>charles同上</p>
<h4 id="http协议详情"><a name="http协议详情" class="anchor-navigation-ex-anchor" href="#http协议详情"><i class="fa fa-link" aria-hidden="true"></i></a>Http协议详情</h4>
<blockquote>
<p> 前端重点、面试重点、日常常用</p>
</blockquote>
<h5 id="http协议内容和方法"><a name="http协议内容和方法" class="anchor-navigation-ex-anchor" href="#http协议内容和方法"><i class="fa fa-link" aria-hidden="true"></i></a>Http协议内容和方法</h5>
<ul>
<li><p>GET</p>
<p>从服务器获取资源</p>
</li>
<li><p>POST</p>
<p>在服务器创建资源</p>
</li>
<li><p>PUT</p>
<p>在服务器修改资源（幂等性）</p>
</li>
<li><p>DELETE</p>
<p>在服务器删除资源</p>
</li>
<li><p>OPTION</p>
<p>跨域</p>
</li>
<li><p>TRACE</p>
<p>显示调试信息，多数网站不支持</p>
</li>
<li><p>CONENECT</p>
<p>代理</p>
</li>
<li><p>PATCH</p>
<p>对资源进行部分更新（很少使用）</p>
</li>
</ul>
<h5 id="常见http状态吗"><a name="常见http状态吗" class="anchor-navigation-ex-anchor" href="#常见http状态吗"><i class="fa fa-link" aria-hidden="true"></i></a>常见Http状态吗</h5>
<p>1xx：提供信息</p>
<ul>
<li>100 continue</li>
<li>101 切换协议（switch protocol）</li>
</ul>
<p>2xx：</p>
<ul>
<li>200 OK</li>
<li>201 Created 已创建</li>
<li>202 Accepted 已接受</li>
<li>203 Non Authoritative Information 非权威内容（中间的代理服务器修改过内容）</li>
<li>204 No Content 没有内容</li>
<li>205 Reset Content 重置内容</li>
<li>206 Partial Content 服务器下发了部分内容（range header）</li>
</ul>
<p>3xx：重定向</p>
<ul>
<li>300 Multiple Choices 用户请求了多个选项的资源（返回链接选项列表）</li>
<li>301 Moved Permanently 永久转移</li>
<li>302 Found 资源被找到（临时转移）</li>
<li>303 See Other 可以使用GET方法在另一个URL找到资源</li>
<li>304 Not Modified 没有修改（在缓存部分）</li>
<li>305 Use Proxy 需要代理</li>
<li>307 Temporary Redirect 临时重定向</li>
<li>308 Permanent Redirect 永久重定向</li>
</ul>
<p>301 vs 308</p>
<blockquote>
<p>资源被永久移动到新的地址</p>
<p>客户端收到308请求后，之前是什么method，那么之后也会沿用这个method到新地址</p>
<p>客户端收到301请求后，通常用户会想新地址发起GET请求</p>
</blockquote>
<p>302 vs 303 vs 307</p>
<blockquote>
<p>临时重定向，资源临时放到新地址</p>
<p>302时http1.0提出的，最早叫做Moved Temporarily；很多浏览器没有遵循标准，把所有请求都重定向为GET</p>
<p>1999年标准委员会增加了303/307，并将302重新定义为Found</p>
<p>303告诉客户端使用GET方法重定向资源</p>
<p>307告诉客户端使用原请求的method重定向资源</p>
</blockquote>
<p>4xx：客户端错误</p>
<ul>
<li>400 Bad Request 请求格式错误</li>
<li>401 Unauthorized 没有授权（跳登陆）</li>
<li>402 Payment Required 请先付费</li>
<li>403 Forbidden 禁止访问（没有权限）</li>
<li>404 Not Found 没有找到</li>
<li>405 Method Not Allowed 方法不被允许（只接受post 但是发送了get）</li>
<li>406 Not Acceptable 服务端可以提供的内容和客户端期待的不一样</li>
</ul>
<p>5xx：服务器错误</p>
<ul>
<li>500 Internal Server Error 内部服务器错误（崩掉了）</li>
<li>501 Not Implemented 没有实现（接口还未实现）</li>
<li>502 Bad Gateway 网关错误（网关给的）</li>
<li>503 Sevice Unavailable 服务不可用（线程池满了，内存用光了等）</li>
<li>504 Gateway Timeout 网关超时（网关给的）</li>
<li>505 HTTP Version Not Supported版本不支持（http2.0请求http1.0时）</li>
</ul>
<h5 id="常见http头"><a name="常见http头" class="anchor-navigation-ex-anchor" href="#常见http头"><i class="fa fa-link" aria-hidden="true"></i></a>常见Http头</h5>
<p><strong>Content-Length</strong> </p>
<hr>
<p>发送给接收者的Body内容长度（字节）</p>
<p>一个字节byte是 8 bit</p>
<p>utf-8编码的字符是1-4个字节</p>
<p><strong>User-Agent</strong></p>
<hr>
<p>帮助区分客户端特性的字符串</p>
<p>操作系统、浏览器类型、制造商、内核类型、版本号……</p>
<p><strong>Content-Type</strong></p>
<hr>
<p>帮助区分资源的媒体类型（Media Type/MIME Type）</p>
<p>text/html、text/css、application/json、image/jpeg……</p>
<p><strong>Origin</strong></p>
<hr>
<p>描述请求来源地址</p>
<p>scheme://host:port</p>
<p>不含路径，可以是null</p>
<p><strong>Accept</strong></p>
<hr>
<p>建议服务端返回何种媒体类型（MIME Type）</p>
<p>/*代表所有类型</p>
<p>多个类型用逗号隔开text/html,text/css</p>
<p><strong>Accept-Encoding</strong></p>
<hr>
<p>建议服务器发送那种编码（压缩算法）</p>
<p>gzip、deflate;q=1.0, *;q=0.5</p>
<p><code>;</code>后的q是权重<code>,</code>来分开组别</p>
<p><strong>Accept-Language</strong></p>
<hr>
<p>建议服务端传递哪种语言</p>
<p>fr-CH,fr;q=0.9,en;q=0.8,*;q=0.5</p>
<p><strong>Referer</strong></p>
<hr>
<p>告诉服务端打开当前页面的上一张页面的URL；如果是ajax请求那么就告诉服务端发送请求的URL是什么</p>
<p>由于它会形成一条链，所以常用来分析用户行为</p>
<p>非浏览器环境有时候不发送Referer（或者爬虫来做虚拟Referer）</p>
<p><strong>Connection</strong></p>
<hr>
<p>决定连接是否在当前事务完成后关闭</p>
<p>Http1.0默认是close</p>
<p>Http1.1后默认是keep-alive</p>
<h4 id="全栈角度看http协议"><a name="全栈角度看http协议" class="anchor-navigation-ex-anchor" href="#全栈角度看http协议"><i class="fa fa-link" aria-hidden="true"></i></a>全栈角度看Http协议</h4>
<blockquote>
<p>实践巩固、全栈应用、架构思想</p>
</blockquote>
<h5 id="method和解析body"><a name="method和解析body" class="anchor-navigation-ex-anchor" href="#method和解析body"><i class="fa fa-link" aria-hidden="true"></i></a>Method和解析Body</h5>
<h5 id="跳转header和3xx状态吗"><a name="跳转header和3xx状态吗" class="anchor-navigation-ex-anchor" href="#跳转header和3xx状态吗"><i class="fa fa-link" aria-hidden="true"></i></a>跳转Header和3xx状态吗</h5>
<p>认真对待3xx状态码</p>
<h5 id="错误处理4xx和5xx"><a name="错误处理4xx和5xx" class="anchor-navigation-ex-anchor" href="#错误处理4xx和5xx"><i class="fa fa-link" aria-hidden="true"></i></a>错误处理4xx和5xx</h5>
<p>错误处理遵循协议约定</p>
<h4 id="加密和https证书"><a name="加密和https证书" class="anchor-navigation-ex-anchor" href="#加密和https证书"><i class="fa fa-link" aria-hidden="true"></i></a>加密和Https证书</h4>
<blockquote>
<p>面试重点、前端重点、架构思想</p>
</blockquote>
<h5 id="对称加密和非对称加密"><a name="对称加密和非对称加密" class="anchor-navigation-ex-anchor" href="#对称加密和非对称加密"><i class="fa fa-link" aria-hidden="true"></i></a>对称加密和非对称加密</h5>
<p>明文传输非常不安全，导致各大厂商需要自己加密。</p>
<p>加密解密的方法称为「密钥」</p>
<p>对称加密：</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/01cef31e34932f7f8421ed72dec4881d.png" alt="对称"></p>
<p>非对称加密：</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/910d75450f58047a9fbd539fd17a8040.png" alt="非对称"></p>
<ul>
<li><p>创建者创建一个密钥对（公钥和私钥）</p>
</li>
<li><p>公钥加密必须私钥解密</p>
</li>
<li><p>私钥加密必须公钥解密</p>
</li>
<li><p>创建者保留私钥，公钥向外界公开</p>
</li>
</ul>
<h5 id="解决信任问题"><a name="解决信任问题" class="anchor-navigation-ex-anchor" href="#解决信任问题"><i class="fa fa-link" aria-hidden="true"></i></a>解决信任问题</h5>
<p>通过第三方机构的证书来验证 某网站的证书是否可信</p>
<p><a href="https://jpg.dog/i/265bG" target="_blank"><img src="https://i.jpg.dog/file/jpg-dog/c913aa01863d1eb0fbf68e3d4b17fb77.png" alt="信任解决"></a></p>
<p>在根证书上的验证方式</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/cd5f2234ec947a2f47d84546f358d702.png" alt="根证书"></p>
<p>实际上的证书体系，比较复杂</p>
<p><img src="https://i.jpg.dog/file/jpg-dog/3e8245938169918549c092feede9da89.png" alt="实际上的根证书"></p>
<h5 id="常见算法介绍"><a name="常见算法介绍" class="anchor-navigation-ex-anchor" href="#常见算法介绍"><i class="fa fa-link" aria-hidden="true"></i></a>常见算法介绍</h5>
<p>DES（Data Encryption Standard）</p>
<blockquote>
<p>8bit = 1byte</p>
</blockquote>
<p>著名的<strong>对称加密算法</strong>，将64bits原文和56bits密钥进行DES加工成64bits密文；可暴力破解</p>
<p>AES（Advanced Encryption Standard）</p>
<p>2001年美国国家标准于技术研究院发布的<strong>对称加密算法</strong></p>
<p>可旁道攻击（通过硬件表现，猜出来算法过程）</p>
<p>RSA（Rivest-Shamir- Adleman）</p>
<p><strong>非对称加密算法</strong>，三个人的名字命名</p>
<h5 id="对称与非对称的区别"><a name="对称与非对称的区别" class="anchor-navigation-ex-anchor" href="#对称与非对称的区别"><i class="fa fa-link" aria-hidden="true"></i></a>对称与非对称的区别</h5>
<p>非对称加密安全性更好</p>
<p>对称加密计算速度更快</p>
<p>通常混合使用（利用非对称加密协商密钥，然后进行对称加密通信）</p>
<h5 id="https建立连接到工作的过程"><a name="https建立连接到工作的过程" class="anchor-navigation-ex-anchor" href="#https建立连接到工作的过程"><i class="fa fa-link" aria-hidden="true"></i></a>https建立连接到工作的过程</h5>
<p><img src="https://i.jpg.dog/file/jpg-dog/b3d9bcdc05a5d50839898919066a2c4a.png" alt="https"></p>
<h4 id="udp和tcp、https2030"><a name="udp和tcp、https2030" class="anchor-navigation-ex-anchor" href="#udp和tcp、https2030"><i class="fa fa-link" aria-hidden="true"></i></a>UDP和TCP、Https2.0/3.0</h4>
<blockquote>
<p>面试重点、前端重点、架构思想</p>
</blockquote>
<h5 id="tcp-vs-udp"><a name="tcp-vs-udp" class="anchor-navigation-ex-anchor" href="#tcp-vs-udp"><i class="fa fa-link" aria-hidden="true"></i></a>TCP vs UDP</h5>
<p>TCP面向流（API接收流）、UDP面向消息（API接收数据包）</p>
<p>场景上：TCP远程控制、UDP查询DNS</p>
<p>UDP：User Data Diagram</p>
<p>需要用户在应用层定义相应机制</p>
<ul>
<li><p>不需要建立连接（延迟更低</p>
</li>
<li><p>封包提及更小（传输速度快</p>
</li>
<li>不关心数据顺序（不需要ACK</li>
<li>不保证数据不丢失</li>
</ul>
<h5 id="http20"><a name="http20" class="anchor-navigation-ex-anchor" href="#http20"><i class="fa fa-link" aria-hidden="true"></i></a>http2.0</h5>
<p>http2.0最显著的特征是帧(Frame)和流(Steam)</p>
<p>h2中数据的传输单位以二进制数据帧的形式存在，传输形式依赖于流（也就是多个帧组成），每一个数据帧都会标识出属于哪一个流（通过流的ID），而在每一个TCP连接中可以存在并行的多个流，也就是可以发出多个请求，这便是多路复用；h1中的序列与阻塞机制被摒弃后，也就避免了队头阻塞的发生，接收端只管接收数据帧便可，不用担心丢失阻塞问题，每一个帧都有ID标识，在接受完毕后就可以组成完整的请求文件。</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/http的发展模型.png" alt="发展模型"></p>
<ul>
<li><p>多个请求多路复用</p>
<p>多路复用：把相近的请求混合在一起请求过去，相当于并行</p>
</li>
<li><p>防止队头阻塞</p>
<p>队头阻塞：http1.1中的TCP长连接承载多个请求，在上一个请求A还未被响应时，后边的请求B自然就被阻塞了。</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/http.png" alt="队头阻塞"></p>
</li>
<li><p>压缩HTTP头部（HPACK）</p>
<p>类似于摩尔斯电码，用数字代替字符串</p>
</li>
<li><p>服务端推送</p>
<p>在发现客户端请求的<code>html</code>文件里有关联的<code>css</code>、<code>js</code>文件时，会自动将<code>css</code>、<code>js</code>一并推送返回给客户端</p>
</li>
</ul>
<p>http2.0已经摒弃了雪碧图，</p>
<p>还需要GZIP，</p>
<p>不需要js/css文件合并，但需要js压缩</p>
<p>需要首屏优化</p>
<h5 id="http30"><a name="http30" class="anchor-navigation-ex-anchor" href="#http30"><i class="fa fa-link" aria-hidden="true"></i></a>http3.0</h5>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/http3.0模型.png" alt="http3.0"></p>
<h5 id="详解帧frame和流stream"><a name="详解帧frame和流stream" class="anchor-navigation-ex-anchor" href="#详解帧frame和流stream"><i class="fa fa-link" aria-hidden="true"></i></a>详解帧(Frame)和流(Stream)</h5>
<p>帧（frame）</p>
<p>HTTP/2 中<strong>数据传输的最小单位</strong>，因此帧不仅要细分表达 HTTP/1.x 中的各个部份，也优化了 HTTP/1.x 表达得不好的地方，同时还增加了 HTTP/1.x 表达不了的方式。 每一帧都包含几个字段，有<strong>length、type、flags、stream identifier、frame playload</strong>等</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/数据帧的结构.png" alt="数据帧的结构"></p>
<p>帧的字段含义</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length</td>
<td>3 字节</td>
<td>表示帧负载的长度，默认最大帧大小2^14</td>
</tr>
<tr>
<td>Type</td>
<td>1 字节</td>
<td>当前帧的类型，下面会做介绍</td>
</tr>
<tr>
<td>Flags</td>
<td>1 字节</td>
<td>具体帧的标识</td>
</tr>
<tr>
<td>R</td>
<td>1 字节</td>
<td>保留位，不需要设置，否则可能带来严重后果</td>
</tr>
<tr>
<td>Stream Identifier</td>
<td>31 位</td>
<td>每个流的唯一ID</td>
</tr>
<tr>
<td>Frame Payload</td>
<td>不固定</td>
<td>真实帧的长度，真实长度在Length中设置</td>
</tr>
</tbody>
</table>
<p>其中type 代表帧的类型，在 HTTP/2 的标准中定义了 10 种不同的类型，包括上面所说的 HEADERS frame 和 DATA frame。此外还有： <code>PRIORITY</code>（设置流的优先级） <code>RST_STREAM</code>（终止流） <code>SETTINGS</code>（设置此连接的参数） <code>PUSH_PROMISE</code>（服务器推送） <code>PING</code>（测量 RTT） <code>GOAWAY</code>（终止连接） <code>WINDOW_UPDATE</code>（流量控制） <code>CONTINUATION</code>（继续传输头部数据）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATA</td>
<td>0x0</td>
<td>传输流的核心内容</td>
</tr>
<tr>
<td>HEADERS</td>
<td>0x1</td>
<td>包含HTTP首部，和可选的优先级参数</td>
</tr>
<tr>
<td>PRIORITY</td>
<td>0x2</td>
<td>指示或者更改流的优先级和依赖</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>0x3</td>
<td>允许一端停止流（通常是由于错误导致的）</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>0x4</td>
<td>协商连接级参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>0x5</td>
<td>提示客户端，服务端要推送些东西</td>
</tr>
<tr>
<td>PING</td>
<td>0x6</td>
<td>测试连接可用性和往返时延（RTT）</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>0x7</td>
<td>告诉另外一端，当前端已结束</td>
</tr>
<tr>
<td>WINDOW_UPDATE</td>
<td>0x8</td>
<td>协商一端要接收多少字节（用于流量控制）</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>0x9</td>
<td>用以拓展HEADER数据块</td>
</tr>
</tbody>
</table>
<p>在 HTTP 2.0 中，它把数据报的两大部分分成了 header frame 和 data frame。也就是头部帧和数据体帧。</p>
<p>流（stream）</p>
<p>流： 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。 HTTP/2 长连接中的数据包是不按请求-响应顺序发送的，一个完整的请求或响应(称一个数据流 stream，每个数据流都有一个独一无二的编号)可能会分成非连续多次发送。它具有如下几个特点：</p>
<ul>
<li><strong>双向性：同一个流内，可同时发送和接受数据</strong>。</li>
<li><strong>有序性：流中被传输的数据就是二进制帧 。帧在流上的被发送与被接收都是按照顺序进行的</strong>。</li>
<li><strong>并行性：流中的 二进制帧 都是被并行传输的，无需按顺序等待</strong>。</li>
<li><strong>流的创建：流可以被客户端或服务器单方面建立, 使用或共享</strong>。</li>
<li><strong>流的关闭：流也可以被任意一方关闭</strong>。</li>
<li><strong>HEADERS 帧在 DATA 帧前面</strong>。</li>
<li><strong>流的 ID 都是奇数，说明是由客户端发起的，这是标准规定的，那么服务端发起的就是偶数了</strong>。</li>
</ul>
<h3 id="网络请求实战"><a name="网络请求实战" class="anchor-navigation-ex-anchor" href="#网络请求实战"><i class="fa fa-link" aria-hidden="true"></i></a>1.1.4. 网络请求实战</h3>
<h4 id="restful约定和postman工具"><a name="restful约定和postman工具" class="anchor-navigation-ex-anchor" href="#restful约定和postman工具"><i class="fa fa-link" aria-hidden="true"></i></a>RESTFUL约定和Postman工具</h4>
<blockquote>
<p>工作日常、面试重点、大厂生态</p>
</blockquote>
<h5 id="restful（representationnal-state-transfer）"><a name="restful（representationnal-state-transfer）" class="anchor-navigation-ex-anchor" href="#restful（representationnal-state-transfer）"><i class="fa fa-link" aria-hidden="true"></i></a>RESTFUL（Representationnal state transfer）</h5>
<p>表现层状态转化</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/RESTFUL.png" alt="RETFUL"></p>
<p>资源（Resource）</p>
<ul>
<li>服务端的一个资源</li>
<li>拥有URL</li>
</ul>
<p>表示（Representation）</p>
<ul>
<li>服务端的资源在客户端的表示</li>
<li>客户端拥有操作服务端资源的方法</li>
</ul>
<p>转换（Transfer）</p>
<ul>
<li>客户端收到新的表示（状态），从而向用户展现新的内容</li>
</ul>
<p>RESTFUL的内容：</p>
<ul>
<li><p>资源命名</p>
<p>使用名词性词组</p>
<p>用户登录<code>/user/login</code> =&gt; <code>/token</code></p>
</li>
<li><p>状态</p>
<p>客户端是无状态的（statless），从服务端请求来资源<strong>表示</strong>，客户端直接将表示转化为<strong>展示</strong></p>
<p>产品列表<code>GET/products</code> =&gt; 产品列表组件展示</p>
</li>
<li><p>统一</p>
<p>资源ID前后端统一</p>
<p>描述性强</p>
<p>按照规范的HTTP状态码</p>
</li>
</ul>
<p>CURD（约定）</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/CURD约定.png" alt="完整的约定示例"></p>
<p>RESTFUL的优点：</p>
<ul>
<li>客户端无业务状态（简化开发）</li>
<li>资源独立，接口间独立（缓存好设计）</li>
<li>对协议依赖不严重（可迁移）</li>
</ul>
<h5 id="postman的使用"><a name="postman的使用" class="anchor-navigation-ex-anchor" href="#postman的使用"><i class="fa fa-link" aria-hidden="true"></i></a>Postman的使用</h5>
<p>mocha/jest</p>
<p>mock.js</p>
<h4 id="fetch和promise"><a name="fetch和promise" class="anchor-navigation-ex-anchor" href="#fetch和promise"><i class="fa fa-link" aria-hidden="true"></i></a>Fetch和Promise</h4>
<blockquote>
<p>工作日常、面试重点、程序架构</p>
</blockquote>
<h5 id="promise神器"><a name="promise神器" class="anchor-navigation-ex-anchor" href="#promise神器"><i class="fa fa-link" aria-hidden="true"></i></a>Promise神器</h5>
<h5 id="fetch的基本用法"><a name="fetch的基本用法" class="anchor-navigation-ex-anchor" href="#fetch的基本用法"><i class="fa fa-link" aria-hidden="true"></i></a>Fetch的基本用法</h5>
<ul>
<li><p>返回Promise</p>
</li>
<li><p>Resolve发生在网络通信正常（404，500也是resolve）</p>
</li>
<li><p>Reject发生在网络通信异常</p>
</li>
<li><p>默认不接受cookie</p>
</li>
</ul>
<p>一个处理http pipeline更容易的工具</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/pipeline.png" alt="pipeline"></p>
<h5 id="实战"><a name="实战" class="anchor-navigation-ex-anchor" href="#实战"><i class="fa fa-link" aria-hidden="true"></i></a>实战</h5>
<p>应对不稳定的网络环境-指数补偿</p>
<blockquote>
<p>按照指数的时间倍数重复发送请求</p>
<p>0ms - 200ms - 400ms - 800ms - 1600ms </p>
</blockquote>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">let</span> resolved = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">let</span> t = <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFetch</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">if</span>(resolved || t &gt; <span class="hljs-number">16</span>){
        <span class="hljs-keyword">return</span> 
      }
      fetch(url).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> resp.text()
      })
      .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">// 如果发现已经已经被解决掉了就不再resolve</span>
        <span class="hljs-keyword">if</span>(!resolved){
            resolve(data)
            resolved = <span class="hljs-literal">true</span>
        }     
      })
      <span class="hljs-comment">// 直接同步调用doFetch就会形成递归调用</span>
      <span class="hljs-comment">// 所以套一个setTimeout变成异步调用</span>
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
          doFetch()
        t *= <span class="hljs-number">2</span>
      },t*<span class="hljs-number">100</span>)
    }
  })
}
</code></pre>
<p>并发处理和时间窗口(类似于节流)</p>
<p>多个资源并发请求，基于时间窗口过滤重复请求</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">window_it</span>(<span class="hljs-params">f,time = <span class="hljs-number">50</span></span>)</span>{

}
</code></pre>
<h4 id="实战文件上传"><a name="实战文件上传" class="anchor-navigation-ex-anchor" href="#实战文件上传"><i class="fa fa-link" aria-hidden="true"></i></a>实战文件上传</h4>
<blockquote>
<p>工作日常、面试重点</p>
</blockquote>
<h5 id="表单提交方式"><a name="表单提交方式" class="anchor-navigation-ex-anchor" href="#表单提交方式"><i class="fa fa-link" aria-hidden="true"></i></a>表单提交方式</h5>
<ul>
<li>FormData是用来表示表单数据的一个对象<ul>
<li>里边是key/value</li>
<li>用boundary分隔</li>
</ul>
</li>
<li>观察用表单提交数据是POST到服务端的数据body是怎样的？</li>
<li>观察用表单提交文件时body是怎样的？</li>
<li>Express如何接受表单提交的数据？</li>
</ul>
<h5 id="html5方式"><a name="html5方式" class="anchor-navigation-ex-anchor" href="#html5方式"><i class="fa fa-link" aria-hidden="true"></i></a>HTML5方式</h5>
<p>H5通过将文件(这里的文件是blob数据)转为base64放入body里，然后JSON化提交，服务端拿到之后，直接把base64转成文件。</p>
<p>base64:</p>
<p>用64个可打印字符来编码二进制（A-Za-z0-9+，）</p>
<ul>
<li>0-255的ASCII码有许多不能打印的字符</li>
<li>不能打印的字符就不需要在中间过程中转义，如空格变成%2f，其实是不需要的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/base64的编码过程.png" alt="base64"></p>
<p>Man = base64 =&gt; TWFu</p>
<p>但是base64会将文件变大，还是通过FormData的形式保存并放入body传递比较快CPU压力会更小</p>
<blockquote>
<p>上传文件和提交输入框中的字段没有本质的区别</p>
<p>Base64方法速度慢，没有特殊原因通常用blob转FormData上传</p>
</blockquote>
<h4 id="实战websocket聊天室"><a name="实战websocket聊天室" class="anchor-navigation-ex-anchor" href="#实战websocket聊天室"><i class="fa fa-link" aria-hidden="true"></i></a>实战websocket聊天室</h4>
<blockquote>
<p>工作日常、面试重点、程序训练</p>
</blockquote>
<h5 id="websocket协议初探"><a name="websocket协议初探" class="anchor-navigation-ex-anchor" href="#websocket协议初探"><i class="fa fa-link" aria-hidden="true"></i></a>WebSocket协议初探</h5>
<p>一个基于TCP的通信协议，会（带着特定头部）复用HTTP的握手，在连接中会有websocket的自己的封包以二进制传输。</p>
<blockquote>
<p>因为服务端无法主动的向客户端发送信息，所以建立一个稳定的通道WebSocket，可以频繁的互相的主动发消息。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/websocket的连接.png" alt="WebSocket的连接"></p>
<p>websocket的握手-web</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&apos;ws://chat.svc&apos;</span>)
<span class="hljs-comment">// wss -&gt; WebSocket Secure</span>
<span class="hljs-comment">// https -&gt; tls.ssl - tcp/ip</span>
<span class="hljs-comment">// wss - tls - tcp/ip</span>
client.onopen = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;connnet OK!&apos;</span>)
}
</code></pre>
<p>websocket的握手-node</p>
<pre><code class="lang-javascript">const server = net.createSercer()

server.on(&apos;connection&apos;.socket =&gt; {
  socket.on(&apos;data&apos;,(buffer)=&gt;{

    // 返回
    const sha1 = cryptp.createHash(&apos;sha1&apos;)
    sha1.update(headers[&apos;sec-websocket-key&apos;]+&apos;258...&apos;)
    const acceptKey = sha1.digest(&apos;base64&apos;)
    let response = &apos;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-Websocket-Accept: ${acceptKey}

    // 这里要空一行，因为http中的body和头部就差一行
    // 如果没有这一行，浏览器就会一直等待body
    // 且每一项前边不可以有空格
    &apos;

    socket.write(response)
  })
})
</code></pre>
<h5 id="聊天室-node端"><a name="聊天室-node端" class="anchor-navigation-ex-anchor" href="#聊天室-node端"><i class="fa fa-link" aria-hidden="true"></i></a>聊天室-node端</h5>
<blockquote>
<p>如果需要下载聊天记录，那就新建一个连接，这个链接是socket还是http都可以</p>
</blockquote>
<p>socket.io</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
<span class="hljs-comment">// 发送信息</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">type,message,sender</span>)</span>{
  socket.send(type,message,sender)
}
io.on(<span class="hljs-string">&apos;connect&apos;</span>,socket =&gt;{
  <span class="hljs-comment">// data {type,message}</span>
  socket.on(<span class="hljs-string">&apos;message&apos;</span>,data =&gt; {

    swich(data.type){
      <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;LOGIN&apos;</span>:
          users.set(socket,{<span class="hljs-attr">name</span>:data.name})
          broadcast(<span class="hljs-string">&apos;LOGIN&apos;</span>,${data.name} + <span class="hljs-string">&apos;join in!&apos;</span>)

          <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;CHAT&apos;</span>:
          <span class="hljs-keyword">const</span> user = users.get(scoket)
        broadcast(<span class="hljs-string">&apos;CHAT&apos;</span>, data.message, user.name)
          <span class="hljs-keyword">break</span>
    }
  })
})
</code></pre>
<h5 id="聊天室-web端"><a name="聊天室-web端" class="anchor-navigation-ex-anchor" href="#聊天室-web端"><i class="fa fa-link" aria-hidden="true"></i></a>聊天室-web端</h5>
<p>socket.io</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&apos;ws://chat.svc:8080&apos;</span>)
<span class="hljs-keyword">const</span> name = <span class="hljs-string">&apos;user &apos;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()
socket.send({
  <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;LOGIN&apos;</span>,
  name
})

<span class="hljs-comment">// 发送消息</span>
cosnt ipt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&apos;ipt&apos;</span>)
ipt.addEventLisetener(<span class="hljs-string">&apos;keyup&apos;</span>,e=&gt;{
    <span class="hljs-keyword">if</span>(e.key === <span class="hljs-string">&apos;Enter&apos;</span>) send()
})
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> val = ipt.value
  <span class="hljs-keyword">if</span>(val === <span class="hljs-string">&apos;&apos;</span>){
    <span class="hljs-keyword">return</span> 
  }
  socket.send({
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CHAT&quot;</span>,
    <span class="hljs-attr">message</span>: val
  })
  ipt.value = <span class="hljs-string">&apos;&apos;</span>
  ipt.focues()
}
</code></pre>
<p>websocket中tcp握手和协议转换的过程很<strong>自然</strong></p>
<p>socket（网络插座）为客户端。服务端提供通信机制</p>
<h4 id="缓存、缓存清理和http缓存"><a name="缓存、缓存清理和http缓存" class="anchor-navigation-ex-anchor" href="#缓存、缓存清理和http缓存"><i class="fa fa-link" aria-hidden="true"></i></a>缓存、缓存清理和HTTP缓存</h4>
<blockquote>
<p>工作日常、面试重点、架构思想</p>
</blockquote>
<h5 id="缓存介绍"><a name="缓存介绍" class="anchor-navigation-ex-anchor" href="#缓存介绍"><i class="fa fa-link" aria-hidden="true"></i></a>缓存介绍</h5>
<p>存储将被用到的数据，让数据访问更快。</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/缓存的过程.png" alt="缓存的过程"></p>
<ul>
<li>命中：在缓存中找到了请求的数据</li>
<li>不命中/穿透：缓存中没有找到需要的数据</li>
<li>命中率：命中次数/总次数</li>
<li>缓存大小：缓存中一共可以存多少数据</li>
<li>清空策略：如果缓存空间不够时，数据如何被替换</li>
</ul>
<p>FIFO的清空策略</p>
<p>先进先出队列</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/FIFO缓存策略.png" alt="FIFO的清空策略"></p>
<p>LFU-Least Frequently used</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/LFU.png" alt="LFU"></p>
<p>LRU-Least Recently used</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/LRU.png" alt="LRU"></p>
<h5 id="实战：fifo的memory函数"><a name="实战：fifo的memory函数" class="anchor-navigation-ex-anchor" href="#实战：fifo的memory函数"><i class="fa fa-link" aria-hidden="true"></i></a>实战：FIFO的memory函数</h5>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fib</span>(<span class="hljs-params">n</span>)</span>{
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>){
    <span class="hljs-keyword">return</span> n
  }
  <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>)
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memory</span>(<span class="hljs-params">f,maxSize = <span class="hljs-number">10</span></span>)</span>{
  <span class="hljs-keyword">const</span> cache = []
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> hash = args.join(<span class="hljs-string">&apos;,&apos;</span>)
    <span class="hljs-comment">// sheji mingzhong</span>
    <span class="hljs-keyword">const</span> item = cache.find(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.hash ===hash)
    <span class="hljs-comment">// 如果 命中</span>
    <span class="hljs-keyword">if</span>(item) {
      <span class="hljs-keyword">return</span> item.value
    }
    <span class="hljs-comment">// 如果没有命中</span>
    <span class="hljs-keyword">const</span> result = f(...args)
    cache.push({hash,<span class="hljs-attr">value</span>:result})
    <span class="hljs-comment">// 如果缓存长度超过maxSize，就要推出末尾的缓存</span>
    <span class="hljs-keyword">if</span>(cache.length &gt; maxSize){
      cache.shift()
    }
    <span class="hljs-keyword">return</span> result
  }
}
<span class="hljs-keyword">const</span> fib = memory(_fib, <span class="hljs-number">10</span>)
</code></pre>
<h5 id="实战：lru算法的缓存"><a name="实战：lru算法的缓存" class="anchor-navigation-ex-anchor" href="#实战：lru算法的缓存"><i class="fa fa-link" aria-hidden="true"></i></a>实战：LRU算法的缓存</h5>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memory</span>(<span class="hljs-params">f,maxSize = <span class="hljs-number">10</span></span>)</span>{
  <span class="hljs-keyword">let</span> cache = []
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> hash = args.join(<span class="hljs-string">&apos;,&apos;</span>)
    <span class="hljs-comment">// sheji mingzhong</span>
    <span class="hljs-keyword">const</span> item = cache.find(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.hash ===hash)
    <span class="hljs-comment">// 如果 命中</span>
    <span class="hljs-keyword">if</span>(item) {
      item.time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()
      <span class="hljs-keyword">return</span> item.value
    }
    <span class="hljs-comment">// 如果没有命中</span>
    <span class="hljs-keyword">const</span> result = f(...args)
    cache.push({hash,
                <span class="hljs-attr">value</span>:result,
                <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()})
    <span class="hljs-comment">// 如果缓存长度超过maxSize，就要推出时间最堵啊的呢的缓存</span>
    <span class="hljs-keyword">if</span>(cache.length &gt; maxSize){
      <span class="hljs-keyword">let</span> min = <span class="hljs-literal">Infinity</span>
      <span class="hljs-keyword">let</span> minItem = <span class="hljs-literal">null</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> cache){
        <span class="hljs-keyword">if</span>(item.time &lt; min){
          min = item.time
          minItem = item
        }
      }
      <span class="hljs-comment">//去掉</span>
      cache = cache.filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span> x!==minItem)
    }
    <span class="hljs-keyword">return</span> result
  }
}
</code></pre>
<h5 id="缓存策略"><a name="缓存策略" class="anchor-navigation-ex-anchor" href="#缓存策略"><i class="fa fa-link" aria-hidden="true"></i></a>缓存策略</h5>
<p>Cache-Control：定义所有缓存都要遵守的行为</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/可缓存性设置属性.png" alt="可缓存行字段"></p>
<p>常见用法：</p>
<p><img src="https://raw.githubusercontent.com/jasonk0/myImage-blog/master/imgs/常见缓存.png" alt="常见"></p>
<p>强制缓存：强制使用浏览器缓存，不请求服务器</p>
<p>直接设置<code>max-age= 360</code>来实现强制缓存。</p>
<p>协商缓存：协商使用缓存，每次需要向服务器请求对比，缓存生效不传回body，也就不更新内容和缓存。</p>
<p>一个是：last-Modified 和 if-Modified-Since</p>
<p>另一个是：Etag 和 if-None-Match</p>
<footer class="page-footer"><span class="copyright">© Jasonk0 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-07-21 08:53:32
</span></footer>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../" class="navigation navigation-prev " aria-label="Previous page: 简介">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="工具链和其他.html" class="navigation navigation-next " aria-label="Next page: 工具链和其他">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"计算机网络","level":"1.2","depth":1,"next":{"title":"工具链和其他","level":"1.2.1","depth":2,"path":"计算机网络/工具链和其他.md","ref":"计算机网络/工具链和其他.md","articles":[]},"previous":{"title":"简介","level":"1.1","depth":1,"path":"README.md","ref":"./README.md","articles":[]},"articles":[{"title":"工具链和其他","level":"1.2.1","depth":2,"path":"计算机网络/工具链和其他.md","ref":"计算机网络/工具链和其他.md","articles":[]},{"title":"浏览器状态同步和路由","level":"1.2.2","depth":2,"path":"计算机网络/浏览器状态同步和路由.md","ref":"计算机网络/浏览器状态同步和路由.md","articles":[]},{"title":"网络安全攻防","level":"1.2.3","depth":2,"path":"计算机网络/网络安全攻防.md","ref":"计算机网络/网络安全攻防.md","articles":[]}],"dir":"ltr"},"config":{"plugins":["chapter-fold","hide-element","tbfed-pagefooter","highlight","code","cmb-pageview","custom-favicon","anchor-navigation-ex"],"root":"bookEdit","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"&copy Jasonk0","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"chapter-fold":{},"search":{},"cmb-pageview":{},"page-toc":{"selector":".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4","position":"top","showByDefault":false},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"code":{"copyButtons":true},"hide-element":{"elements":[".gitbook-link"]},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":true,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"favicon":"icon/favicon.ico","custom-favicon":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"producer":"jasonk0","structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"计算机网络/计算机网络.md","mtime":"2022-07-21T00:53:32.683Z","type":"markdown"},"gitbook":{"version":"3.7.5","time":"2022-07-27T00:38:34.392Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-element/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-cmb-pageview/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

